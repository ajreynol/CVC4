; EXPECT: unsat
; COMMAND-LINE: --sygus-out=status --lang=sygus2 --no-check-synth-sol
(set-logic ALL)

(declare-datatype Packet ((P1) (P2)))

(declare-datatype Node ((A) (B) (C)))

(declare-datatype SPair ((mkPair (pnode Node) (ppacket Packet))))

(declare-datatype State ((mkState (failureQuota Int) (rcv (Array SPair Bool)))))
(declare-datatype StateList ((consSL (headSL State) (tailSL StateList)) (nilSL)))

; C is destination of P1 and P2
(define-fun h_State ((s State)) Int
  (+ 
    (ite (select (rcv s) (mkPair C P1)) 1 0)
    (ite (select (rcv s) (mkPair C P2)) 1 0)
  )
)

; Actions and how they are interpreted

(declare-datatype Action (
  (sleep) 
  (pushPck (push_dst Node) (push_pck Packet))
  (pullPck (pull_src Node) (pull_pck Packet))
))
(declare-datatype ActionList ((consAL (headA Action) (tailA ActionList)) (nilAL)))

;; returns true if action is valid for actor in state s
(define-fun preconditionAction ((actor Node) (a Action) (s State)) Bool
  (let ((rcv (rcv s)))
  (ite ((_ is pullPck) a)
    (let ((pck (pull_pck a)))
    ; don't pull if already recieved the packet
    (not (select rcv (mkPair actor pck)))
    )
    true
  )
  )
)

; which action fires in state s?
(define-fun-rec actionListToAction ((actor Node) (al ActionList) (s State)) Action
  (ite ((_ is consAL) al)
    (let ((a (headA al)))
    (ite (preconditionAction actor a s)
      a
      (actionListToAction actor (tailA al) s)
    )
    )
    sleep
  )
)

(declare-datatype PState ((mkPState (states StateList) (count (Array State Int)))))

(define-fun-rec h_PState_rec ((pssl StateList) (pspb (Array State Int))) Int
  (ite ((_ is consSL) pssl)
    (let ((s (headSL pssl)))
      (+ (* (select pspb s) (h_State s)) (h_PState_rec (tailSL pssl) pspb))
    )
    0)
)
(define-fun h_PState ((ps PState)) Int
  (h_PState_rec (states ps) (count ps))
)

(define-fun nilPState () PState
  (mkPState nilSL ((as const (Array State Int)) 0))
)
(define-fun-rec appendStateToPState ((s State) (n Int) (p PState)) PState
  (let ((pstates (states p)))
  (let ((pcount (count p)))
  (let ((pr (select pcount s)))
  (mkPState
    ; add to list if not there already
    (ite (= pr 0)
      (consSL s pstates)
      pstates
    )
    (store 
      pcount
      s (+ n pr)
    )
  )
  )))
)


(define-fun transNode ((actor Node) (a Action) (r Real) (s State) (psp PState)) PState
  (let ((prevRcv (rcv s)))
  (let ((prevFail (failureQuota s)))
  (ite ((_ is pushPck) a)
    (let ((dst (push_dst a))) 
    (let ((pck (push_pck a)))
    (let ((dst_pair (mkPair dst pck)))
    (let ((src_pair (mkPair actor pck)))
    (let ((allowSuccess (select prevRcv src_pair)))
    (let ((allowFail (> prevFail 0)))
      (appendStateToPState
        ; success
        (mkState prevFail (store prevRcv dst_pair true))
        (ite allowSuccess (ite allowFail 1 2) 0)
      (appendStateToPState
        ; failure that didn't count towards quota
        (mkState prevFail prevRcv)
        (ite allowSuccess 0 (ite allowFail 1 2))
      (appendStateToPState
        ; failure that counts towards quota
        (mkState (- prevFail 1) prevRcv)
        (ite allowFail 1 0)
        psp
      )))
    ))))))
  (ite ((_ is pullPck) a)
    (let ((src (pull_src a))) 
    (let ((pck (pull_pck a)))
    (let ((dst_pair (mkPair actor pck)))
    (let ((src_pair (mkPair src pck)))
    (let ((allowSuccess (select prevRcv src_pair)))
    (let ((allowFail (> prevFail 0)))
      (appendStateToPState
        ; success
        (mkState prevFail (store prevRcv dst_pair true))
        (ite allowSuccess (ite allowFail 1 2) 0)
      (appendStateToPState
        ; failure that didn't count towards quota
        (mkState prevFail prevRcv)
        (ite allowSuccess 0 (ite allowFail 1 2))
      (appendStateToPState
        ; failure that counts towards quota
        (mkState (- prevFail 1) prevRcv)
        (ite allowFail 1 0)
        psp
      )))
    ))))))
    (appendStateToPState
      s 
      2
      psp)
  ))
  ))
)

(define-fun-rec transNodeListRec ((actor Node) (al ActionList) (ps PState) (pssl StateList) (psp PState)) PState
  ; if more states to consider in s
  (ite ((_ is consSL) pssl) 
    (let ((s (headSL pssl)))
    (let ((r (select (count ps) s)))
      (transNode actor (actionListToAction actor al s) r s 
        (transNodeListRec actor al ps (tailSL pssl) psp))
    ))
    psp)
)

(define-fun-rec transNodeList ((actor Node) (al ActionList) (ps PState) (psp PState)) PState
  (transNodeListRec actor al ps (states ps) psp)
)

(define-fun trans ((aa ActionList) (ab ActionList) (ac ActionList) (ps PState)) PState
  ;(transNodeList A aa ps
  ;(transNodeList B ab ps
  (transNodeList C ac ps
    nilPState);))
)

(synth-fun actionA () ActionList
  ((GAL ActionList) (GA Action) (GN Node) (GP Packet))
  (
  (GAL ActionList (nilAL))
  (GA Action ((pushPck GN GP) (pullPck GN GP)))
  (GN Node (B C))
  (GP Packet (P1 P2))
  )
)
(synth-fun actionB () ActionList
  ((GAL ActionList) (GA Action) (GN Node) (GP Packet))
  (
  (GAL ActionList (nilAL))
  (GA Action ((pushPck GN GP) (pullPck GN GP)))
  (GN Node (A C))
  (GP Packet (P1 P2))
  )
)
(synth-fun actionC () ActionList
  ((GAL ActionList) (GA Action) (GN Node) (GP Packet))
  (
  (GAL ActionList ((consAL GA GAL) nilAL))
  (GA Action ((pushPck GN GP) (pullPck GN GP)))
  (GN Node (A B))
  (GP Packet (P1 P2))
  )
)


; A and B initially have packets P1 and P2
(define-fun init-state () State
  (mkState
    ; allow two failures
    2
    (store 
      (store
        ((as const (Array SPair Bool)) false)
        (mkPair B P2) true
      )
      (mkPair A P1) true
    )
  )
)

(define-fun init-pstate () PState
  (appendStateToPState init-state 1 nilPState)
)

; expected value of packets is greater than 1.0 after 2 time steps.
(optimize-synth 
  (h_PState 
    (trans actionA actionB actionC 
    (trans actionA actionB actionC 
    (trans actionA actionB actionC
    (trans actionA actionB actionC 
    (trans actionA actionB actionC 
      init-pstate)))))
  )
)
