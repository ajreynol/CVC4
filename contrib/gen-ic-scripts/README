############## OVERVIEW OF THE WORKFLOW ##############

To use the workflow, at a high level, consists of the following strategy,
given in terms of scripts to run.

```
;; initialize [input_problem.smt2], [input_grammar.sy]
;; clean the directory
run_gen_ic -clean
;; cache the I/O specification of the invertibility condition
run_gen_ic -setup
;; optionally, debug the specification
( run_gen_ic -visual full_io_spec.smt2 )?
(
  ;; decide on a part of the search
  ;; (modify [input_grammar.sy])?
  ;; (modify [input_problem.smt2])?
  run_gen_ic -reset
  (
    ;; *** synthesize a new candidate
    ;; decide on an input grammar, based on the perceived fitness of terms
    ;; (modify [input_grammar.sy])?
    run_gen_ic -synth
    ;; kill the above process when a reasonable candidate is generated
    
    ;; *** test the current candidate
    run_gen_ic -test
    ( 
      ;; if the test succeeded,
      ;; test the current candidate for the entire specification
      run_gen_ic -testfull 
      ;; if verified, we are finished.
    | 
      ;; if the test failed,
      ;; optionally, cache, evaluate, visualize the current candidate
      ( 
        run_gen_ic -eval;
        run_gen_ic -gen [CANDIDATE_FILE] > out.smt2; 
        run_gen_ic -visual out.smt2 
      )?
    )

  )*
)*
```
This loop can also be automated via `run_gen_ic -run`. Notice that using this
option will not necessarily lead to minimal solutions.

The following describes the necessary files to set up for this workflow, and
the intermediate files that are generated, and how they can be modified.


############## INPUTS TO THE WORKFLOW ##############

[input_problem.smt2] 

The definition of the invertibility condition problem. This is, 
in *.smt2 format, the definition of a predicate `input` of the form
    (=> C (~ (op s1 ... (f s1 ... sn t) ... sn) t))
where C is a condition (or "case") of the invertibility condition that we
are currently focusing on. The function application (f s t) is interpreted
as the place for the function to synthesize. In other words, the above
problem is interpreted as 

"find an invertibility condition over s1...sn, t whose I/O behavior matches the
satisfiability of exists x. (~ (op s1 ... x ... sn) t), when C is true."

This file has several special markers used in steps of the procedure:
`__SIG` should mark the unique line that specifies the type of `input`,
`__SC` should mark the unique line that contains a definition of the side
condition, and `__PROBLEM` should mark the unique line that contains the
definition of the literal of the invertibility condition. Each of these three
lines can be modified as desired by the user.

In practice, for BV and FP, `__SIG` should be a reasonable type that
exercizes most of the behaviors of the invertibility condition in question.
The side condition `__SC` is useful for narrowing the search space, for
example, this can be used to ask the workflow to solve the case when
s is always positive.


[input_grammar.sy] 

The input grammar for solving the invertibility condition. This
is a *.sy definition of a synth-fun command for predicate `IC`.
The type of `IC` should match the type of `input` from [input_problem.smt2].
This grammar should be focused on the invertibility condition problem. In
other words, it contains the guess of a class of expressions that contains the
invertibility condition.


[pbe_example_set.sy] 

This corresponds to the approximation of the problem we are currently
considering. This contains, in *.sy format, constraints of the form:
```
  (constraint ([not?] (IC c1 ... cn)))
```
for constants c1, ..., cn. These points are updated by `run_gen_ic -test`
and by `run_gen_ic -testfull`. In both cases, the points appended to this list
are counterexamples to failed candidates. The number of points generated by
these calls can be configured in `run_gen_ic` via the variable `NUM_PBE_PTS`.
Additionally, all points generated by the former satisfy the side condition
from [input_problem.smt2].



############## FILES GENERATED BY THE WORKFLOW ##############

[full_io_spec.smt2]

This is a cache of the I/O behavior of the input problem. This is a definition
of an array `io` whose constituent type is BitVector.


[pbe_examples.sy]

The constraints corresponding to a partial (PBE) specification. This
is a list of *.sy constraints of the form:
```
  (constraint (IC c1 c2))
```
corresponding to the approximate specification we are current testing.


[input_candidates.smt2]

This is the current list of candidate invertibility conditions generated by
the synthesis component of the workflow. This is, in *.smt2 format, a list of
definitions `IC`. The last definition in this list is used as the candidate
invertibility condition when running `run_gen_ic -test`.


[candidate_log.smt2]

This is a list of candidate invertibility conditions that have been tested since
the last call to reset. In other words, these are the input conditions that
have been extracted by `run_gen_ic -test`, where `run_gen_ic -reset` clears this
list.


[candidate_log_overall.smt2]

A concatenation of candidate_log.smt2 generated during the workflow. This is
updated by `run_gen_ic -reset`.


[solutions.smt2]

After a successful call to `run_gen_ic -testfull`, this is updated to contain
the solution of the invertibility condition problem.
