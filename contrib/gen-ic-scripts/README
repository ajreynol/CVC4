############## OVERVIEW OF THE WORKFLOW ##############

To use the workflow, at a high level, consists of the following strategy,
given in terms of scripts to run.

```
;; ----- Init Step 1: 
;; Initialize input_problem.smt2, input_grammar.sy (see below).

;; ----- Init Step 2: 
;; If needed, clean the directory.
run_gen_ic -clean

;; ----- Init Step 3: 
;; Cache the I/O specification of the invertibility condition.
;; This step can take up to 2 hours for two dimensional invertibility
;; conditions for (_ FloatingPoint 3 5), and can be shorter or longer 
;; depending on the operator.
run_gen_ic -setup [--gen-ic-use-eval]?

;; *** The option --gen-ic-use-eval must be used if the satisfiability problem
;; for input_problem.smt2 for fixed values of variables is hard. For example,
;; this is the case if input_problem.smt2 involves FP multiplication.

;; Optionally, visualize the specification. *** This only is intended to work
;; for two dimensional invertibility conditions.
( run_gen_ic -visual full_io_spec.smt2 )?

(
  ;; ----- Step 1: 
  ;; Decide on a part of the search by modifying the side condition in
  ;; input_problem.smt2, by default this is "true".
  
  ;; ----- Step 2: 
  ;; Initialize the synthesis environment.
  run_gen_ic -reset
  
  ;; ----- Step 3:
  ;; Run alternating calls to synthesize/test new candidates.
  (
    ;; ----- Step 3.1: synthesize a new candidate
    ;; Decide on an input grammar, based on the perceived fitness of terms,
    ;; by modify [input_grammar.sy].
    ;; Synthesize a list of solutions (in decendending order of size).
    run_gen_ic -synth
    
    ;; Notice that the user must kill the above process when a reasonable
    ;; candidate is generated.
    
    ;; ----- Step 3.2: test the current candidate
    run_gen_ic -test
    
    ( 
      ;; ----- Step 3.2a:
      ;; If the test succeeded, test the current candidate for the entire
      ;; specification.
      run_gen_ic -testfull 
      ;; If verified, we are finished and solutions.smt2 is appended.
    | 
      ;; ----- Step 3.2b:
      ;; If the test failed, optionally, cache, evaluate, visualize the current
      ;; candidate.
      ( run_gen_ic -eval )?
      ( 
        run_gen_ic -gen [CANDIDATE_FILE].smt2 > [IO_OUT].smt2; 
        run_gen_ic -visual [IO_OUT].smt2 >  [IMAGE_OUT].ppm
      )?
    )

  )*
)*
```

The above loop can also be automated via `run_gen_ic -run`.
However, notice that this option will not necessarily lead to minimal
solutions, nor is it the fastest way to find a solution. In practice, one
needs to allocate a custom amount of time to `run_gen_ic -synth` to wait
for "good" solutions.

The following describes the necessary files to set up for this workflow, and
the intermediate files that are generated, and how they can be modified.


############## INPUTS TO THE WORKFLOW ##############

[input_problem.smt2] 

The definition of the invertibility condition problem. This is, 
in *.smt2 format, an assertion that corresponds to an invertibility condition
problem. Here is an example:

1 (set-logic FP)
2 (define-sort FP () (_ FloatingPoint 3 5))
3 (declare-fun IC (FP FP) Bool)
4 (assert (forall ((s FP) (t FP))
5   (=>
6    (and (fp.isNormal s) (fp.isNormal t))
7    (= (IC s t) (exists ((x FP)) (= (fp.add RNE x s) t)))
8  )))

After declaring a logic and a sort FP, we define the invertibility condition
predicate `IC` on line 3. Notice that the name `IC` is a keyword in this
setting.

On line 4, we give a universal assertion over two floating point variables
s and t. The body of this assertion is an implication. On line 6, we provide
a "side condition" and on line 7 we provide an equivalence between an
application of IC and an existential on line 8.

Overall, the invertibility condition problem asks to find a predicate IC that
holds exactly when the existential formula holds in cases where the side
condition is true. In the above example, we are looking for a predicate that
holds when there exists a solution to x +^RNE s = t, when limited to the
domain of normal floating point values of s and t.

In practice, for BV and FP, the type of IC should be a reasonable type that
exercizes most of the behaviors of the invertibility condition in question.
The side condition is useful for narrowing the search space, for example, this
can be used to ask the workflow to solve the case when s is a normal
floating point value.


[input_grammar.sy] 

The input grammar for solving the invertibility condition. This
is a *.sy definition of a synth-fun command for predicate `IC`.
The type of `IC` should match the type of `IC` from [input_problem.smt2].
This grammar should be focused on the invertibility condition problem. In
other words, it contains the guess of a class of expressions that contains the
invertibility condition.



############## FILES GENERATED BY THE WORKFLOW ##############

[full_io_spec.smt2]

This is a cache of the I/O behavior of the input problem. This is a definition
of an array `io` whose constituent type is BitVector. Each bit in the range
of this array corresponds to a point of the invertibility conditions behavior,
where 0 means it holds, and 1 means it does not.


[pbe_example_set.sy] 

This corresponds to the approximation of the problem we are currently
considering. This contains, in *.sy format, constraints of the form:
```
  (constraint ([not?] (IC c1 ... cn)))
```
for constants c1, ..., cn. These points are updated by `run_gen_ic -reset`,
`run_gen_ic -test` and `run_gen_ic -testfull`. In all cases, the points appended
to this list are counterexamples to failed candidates. The number of points
generated by these calls can be configured in `run_gen_ic` via the variable 
`NUM_PBE_PTS`. Additionally, all points generated by the first two satisfy the
side condition from [input_problem.smt2]. This set can be modified as necessary
if the user has an idea of which points are useful or not useful (although this
is not common).


[input_candidates.smt2]

This is the current list of candidate invertibility conditions generated by
the synthesis component of the workflow. This is, in *.smt2 format, a list of
definitions `IC`. The last definition in this list is used as the candidate
invertibility condition when running `run_gen_ic -test` or 
`run_gen_ic -testfull`. The user can modify this file with a custom `IC` when
they have a manual guess for the next candidate.


[candidate_log.smt2]

This is a list of candidate invertibility conditions that have been tested since
the last call to reset. In other words, these are the input conditions that
have been extracted by `run_gen_ic -test`, where `run_gen_ic -reset` clears this
list.


[candidate_log_overall.smt2]

A concatenation of candidate_log.smt2 generated during the workflow. This is
updated by `run_gen_ic -reset`.


[solutions.smt2]

After a successful call to `run_gen_ic -testfull`, this is updated to contain
the solution of the invertibility condition problem.
