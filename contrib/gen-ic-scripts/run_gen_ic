#!/bin/bash

# the number of PBE points to append to the current problem on failed candidates
NUM_PBE_PTS=10
# the maximal cardinality of a domain type of an invertibility condition
MAX_CARDINALITY=10000
# the copy of cvc4 we are using
CVC4=pr-ajr-cvc4

###############################################

# This outputs the last line in the file $1 if it contains define-fun.
# Otherwise, it reports an error.
function get_candidate()
{
  CANDIDATE=$1
  if grep -q define-fun $CANDIDATE;
  then
    # make new candidate, which is the last from the list in $CANDIDATE
    grep "define-fun" $CANDIDATE > temp.txt
    tail -1 temp.txt
    rm -f temp.txt
  else
    echo "No candidate found in file:"
    echo "*** CANDIDATE FILE"
    cat $CANDIDATE
    echo "*** END"
  fi
}

###############################################

function sanitize()
{
  cat $1 > temp-$1
  echo $2 >> temp-$1
  # remove the "unknown" printed at the end, and the text added in $2
  $CVC4 --dump=raw-benchmark --preprocess-only --output-lang=smt2 temp-$1 | sed "s/unknown//g; s/$2//g"
  rm -rf temp-$1
}

# This generates a *.smt2 file corresponding to the invertibility condition problem.
function mk_input_problem()
{
  # the definition of the input problem
  cat $1
  # finish
  echo "(check-sat)"
}

# Makes a problem input that is an invertibility condition problem concatenated
# with a cached full I/O specification.
function mk_problem_cached()
{
  # the definition of the input problem
  cat $1
  # the cached I/O specification
  cat $2
  # finish
  echo "(check-sat)"
}

# This generates a *.smt2 file that is used to test the correctness of the
# candidate from $2 (built over the grammar in $2) on the invertibility
# condition problem from $1, whose I/O specification has been cached in $4.
function mk_input_to_test_ic_cached()
{
  CANDIDATE=`cat $2`
  # the definition of the input problem, with the declared IC replaced by the definition
  cat $1 | sed "s/(declare-fun IC.*/$CANDIDATE/g"
  # the cached I/O specification
  cat $3
  # finish
  echo "(check-sat)"
}

# This generates a *.sy problem that corresponds to synthesizing the
# invertibility condition for the current approximate specification from
# $2 using the grammar from $1.
function mk_input_to_synth_ic()
{
  # must extract set-logic and sort definitions from the input problem 
  grep "set-logic" $1
  grep "define-sort" $1
  # the sygus grammar
  cat $2
  # the PBE constraints
  cat $3
  echo "(check-synth)"
}
# unconstrained version of above
function mk_input_to_synth_ic_unc()
{
  echo "" > temp.smt2
  mk_input_to_synth_ic $1 $2 temp.smt2
  rm -f temp.smt2
}

function smk_input_to_test_ic_cached()
{
  # santize the input problem
  sanitize $1 "(check-sat)" > temp_input_problem.smt2
  # make the synthesis problem
  # notice we don't use the santized version of input_problem.smt2 here, since
  # CVC4's dumping features don't print defined sorts.
  mk_input_to_synth_ic_unc input_problem.smt2 $2 > temp_input_grammar.sy
  # now, sanitize it
  sanitize temp_input_grammar.sy "(check-synth)" > temp_input_grammar2.sy
  
  # make the candidate
  # must get the definitions for the grammar
  grep "define" temp_input_grammar2.sy > temp-ic.smt2
  # get the candidate definition
  cat $3 >> temp-ic.smt2
  # remove newlines
  tr -d '\n' < temp-ic.smt2 > temp-ic2.smt2
  
  # now ready to call
  mk_input_to_test_ic_cached temp_input_problem.smt2 temp-ic2.smt2 $4
  # clean up
  rm -f temp_input_problem.smt2
  rm -f temp_input_grammar.sy
  rm -f temp_input_grammar2.sy
  rm -f temp-ic.smt2
  rm -f temp-ic2.smt2
}

function smk_input_to_test_ic()
{
  # empty
  echo "" > temp_full_io.smt2
  # now ready to call
  smk_input_to_test_ic_cached $1 $2 $3 temp_full_io.smt2
  # cleanup
  rm -f temp_full_io.smt2
}

# Remove all temporary files generated by the workflow
function clean_temporary()
{
  rm -f temp_pbe_example_set.sy
  rm -f temp_input_to_gen_full_candidate.smt2
  rm -f temp_input_to_gen_full_spec.smt2
  rm -f temp_input_to_test_ic.smt2
  rm -f temp_input_to_eval_ic.smt2
  rm -f temp_input_to_vis_ic.smt2
  rm -f temp_input_to_synth_ic.sy
  rm -f temp-exp.smt2
  rm -f temp.smt2
}

# Clean all files for the workflow (besides full_io_spec.smt2, which is done manually)
function clean_full()
{
  clean_temporary
  
  if [ -e "full_io_spec.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: full_io_spec.smt2 already exists, remove it to continue."
  else
    # set files generated by the workflow to blank
    echo > pbe_example_set.sy
    echo > candidate_log_overall.smt2
    echo > candidate_log.smt2
    echo > input_candidates.smt2
  fi
  # TODO: remove all images?
}

function expand_candidate()
{
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  echo -n "; simplify "
  cat temp_candidate.smt2
  echo
  
  # generate the input problem for cvc4 to test a candidate IC
  smk_input_to_test_ic input_problem.smt2 input_grammar.sy temp_candidate.smt2 > temp_input_to_exp_ic.smt2

  # evaluate the candidate
  $CVC4 --default-dag-thresh=0  --fmf-type-completion-thresh=$MAX_CARDINALITY --gen-ic-simplify temp_input_to_exp_ic.smt2

  # clean up
  rm -f temp_input_to_exp_ic.smt2
  rm -f temp_candidate.smt2
}

###############################################

# should use --gen-ic-use-eval if the satisfiability queries are difficult (takes 5-6 hours for FP(4,5))
function gen_full_io_spec()
{
  # generate the input problem for cvc4 to generate a full I/O specification
  mk_input_problem input_problem.smt2 > temp_input_to_gen_full_spec.smt2

  # generate the full I/O specification (takes 2-3 hours for FP(4,5))
  # notice we limit the generation of I/O tables for types whose cardinality is greater than $MAX_CARDINALITY
  $CVC4 --gen-ic-full --no-gen-ic-use-sc --fmf-type-completion-thresh=$MAX_CARDINALITY temp_input_to_gen_full_spec.smt2 $@

  # clean up
  rm -f temp_input_to_gen_full_spec.smt2
}


function gen_full_io()
{
  # make new candidate, which is the last from the list in $1
  get_candidate $1 > temp_candidate.smt2
  shift;

  # generate the input problem for cvc4 to generate a full I/O specification
  smk_input_to_test_ic input_problem.smt2 input_grammar.sy temp_candidate.smt2 > temp_input_to_gen_full_candidate.smt2

  # generate the full I/O specification for the candidate
  $CVC4 --gen-ic-full --no-gen-ic-use-sc --test-ic-full --fmf-type-completion-thresh=$MAX_CARDINALITY temp_input_to_gen_full_candidate.smt2 $@

  # clean up
  rm -f temp_input_to_gen_full_candidate.smt2
  rm -f temp_candidate.smt2
}

function visual_full_io()
{
  FULL_IO_CANDIDATE=$1;
  shift;

  # generate the input problem for cvc4 to test a candidate IC
  mk_problem_cached input_problem.smt2 $FULL_IO_CANDIDATE > temp_input_to_vis_ic.smt2

  # evaluate the candidate
  $CVC4 --gen-ic-image --gen-ic-read-io-string --fmf-type-completion-thresh=$MAX_CARDINALITY $@ temp_input_to_vis_ic.smt2

  # clean up
  rm -f temp_input_to_vis_ic.smt2
  rm -f temp_candidate.smt2
}

function generate_pbe_examples()
{
  CANDIDATE=$1;
  shift;
  
  # generate the input problem for cvc4 to test a candidate IC
  smk_input_to_test_ic_cached input_problem.smt2 input_grammar.sy $CANDIDATE full_io_spec.smt2 > temp_input_to_test_ic.smt2

  # test the candidate
  $CVC4 --test-ic-full --test-ic-gen --test-ic-random --test-ic-samples=$NUM_PBE_PTS --gen-ic-read-io-string --fmf-type-completion-thresh=$MAX_CARDINALITY $@ temp_input_to_test_ic.smt2

  # clean up
  rm -f temp_input_to_test_ic.smt2
}

function process_pbe_examples()
{
  # ensure candidate log is initialized
  if [ ! -e "candidate_log.smt2" ];
  then
    echo "" > candidate_log.smt2
  fi
  # append the candidate we tried
  cat $1 >> candidate_log.smt2
  if grep -q constraint $2;
  then
    echo "***** Generated new counterexamples:"
    cat $2
    # add to new examples
    cat $2 >> pbe_example_set.sy
    echo "; __FAIL" >> candidate_log.smt2
  elif grep -q VERIFIED $2;
  then
    echo "***** No counterexamples for candidate!!!"
    # copy to solutions
    cat $1 >> solutions.smt2
    echo "; __VERIFY" >> candidate_log.smt2
  else
    echo "***** Internal error during testing."
    echo "***** ERROR"
    cat $2
    echo "***** END"
    echo "; __ERROR" >> candidate_log.smt2
  fi
}

function test_candidate()
{  
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo
  
  # test the candidate, which should either generate new PBE constraints or outputs "VERIFIED"
  generate_pbe_examples temp_candidate.smt2 $@ > temp_pbe_example_set.sy
  
  # process the above output
  process_pbe_examples temp_candidate.smt2 temp_pbe_example_set.sy
  
  # clean up
  rm -f temp_candidate.smt2
  rm -f temp_pbe_example_set.sy
}

function eval_candidate()
{
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo  
  
  # generate the input problem for cvc4 to test a candidate IC
  smk_input_to_test_ic_cached input_problem.smt2 input_grammar.sy temp_candidate.smt2 full_io_spec.smt2 > temp_input_to_eval_ic.smt2

  # evaluate the candidate
  $CVC4 --test-ic-full --no-gen-ic-use-sc --gen-ic-read-io-string --fmf-type-completion-thresh=$MAX_CARDINALITY temp_input_to_eval_ic.smt2

  # clean up
  rm -f temp_input_to_eval_ic.smt2
  rm -f temp_candidate.smt2
}

function quick_test_candidate()
{  
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo
  
  # test the candidate, which should either generate new PBE constraints or outputs "VERIFIED"
  generate_pbe_examples temp_candidate.smt2 $@
  
  # clean up
  rm -f temp_candidate.smt2
}

function synth_candidate()
{
  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_synth_ic input_problem.smt2 input_grammar.sy pbe_example_set.sy > temp_input_to_synth_ic.sy

  # synthesize a new candidate
  $CVC4 --sygus-stream --sygus-pbe --output-lang=smt2 --sygus-out=status-or-def $@ temp_input_to_synth_ic.sy 2>&1 | tee input_candidates.smt2

  # we do not clean up input_candidates.smt2

  # clean up
  rm -f temp_input_to_synth_ic.sy
}

function reset()
{
  # remove files that should be cleaned up anyways
  clean_temporary

  # append to the global candidate log if we tried any candidate
  if grep -q define-fun candidate_log.smt2;
  then
    cat candidate_log.smt2 >> candidate_log_overall.smt2
  fi
  echo > candidate_log.smt2
  # store debugging information in global candidate log
  echo "; -----------------" >> candidate_log_overall.smt2
  
  # intialize the input candidate and the pbe examples
  echo > input_candidates.smt2
  echo > pbe_example_set.sy
  # first two candidates are trivially true, false
  # thus, these should go quickly
  echo "*** Synthesizing first initial candidate..."
  synth_candidate --no-sygus-stream
  echo "***** Testing first initial candidate:"
  test_candidate
  echo "*** Synthesizing second initial candidate..."
  synth_candidate --no-sygus-stream
  echo "***** Testing second initial candidate:"
  test_candidate
}


###############################################


if [ X$1 = X'-reset' ]; 
then
  shift;
  reset $@
  echo
  echo "*** Synthesis environment initialized. Now, run alternating calls to:"
  echo "  run_gen_ic -synth"
  echo "  run_gen_ic -test"
elif [ X$1 = X'-synth' ]; 
then
  shift;
  echo "*** Synthesizing candidates..."
  synth_candidate $@
elif [ X$1 = X'-test' ]; 
then
  shift;
  echo "***** Testing candidate:"
  test_candidate $@
elif [ X$1 = X'-testfull' ]; 
then
  shift;
  echo "***** Testing candidate on all inputs:"
  echo ";;; __FULL" >> candidate_log.smt2
  test_candidate $@ --no-gen-ic-use-sc
  echo ";;;" >> candidate_log.smt2
elif [ X$1 = X'-quicktest' ]; 
then
  shift;
  # test without logging or buffering
  echo "***** Quick test candidate:"
  quick_test_candidate $@
elif [ X$1 = X'-gen' ]; 
then
  shift;
  # generate the full i/o behavior of $1, which a file containing define-fun.
  gen_full_io $@
elif [ X$1 = X'-genspec' ]; 
then
  shift;
  # Generate the full i/o behavior of the input problem
  # This option is useful for "continuing" the generation of a I/O bitstring,
  # in the case of an abnormal termination.
  gen_full_io_spec $@
elif [ X$1 = X'-visual' ]; 
then
  shift;
  # visualize the full i/o behavior of $1, which is an I/O bitstring table.
  visual_full_io $@
elif [ X$1 = X'-expand' ]; 
then
  shift;
  expand_candidate $@
elif [ X$1 = X'-simplify' ]; 
then
  shift;
  expand_candidate $@ --ext-rew-prep --ext-rew-prep-agg
elif [ X$1 = X'-eval' ]; 
then
  shift;
  echo "***** Evaluating candidate:"
  eval_candidate $@
elif [ X$1 = X'-clean' ]; 
then
  shift;
  # clear all auxiliary files except for full_io_spec.smt2
  clean_full
elif [ X$1 = X'-setup' ]; 
then
  shift;
  # Note: only call -setup once per problem
  if [ -e "full_io_spec.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: full_io_spec.smt2 already exists, remove it to continue."
  else
    # clear all auxiliary files
    clean_full
    echo "***** Compute full input/output specification for invertibility condition based on the input problem..."
    gen_full_io_spec $@ 2>&1 | tee full_io_spec.smt2
  fi
elif [ X$1 = X'-run' ]; 
then
  shift;
  if [ -e "solutions.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: solutions.smt2 already exists, remove it to continue."
  else
    reset
    while [ ! -e  "solutions.smt2" ]
    do
      echo "*** Synthesizing candidates..."
      synth_candidate --no-sygus-stream
      echo "***** Testing candidate:"
      test_candidate
    done
  fi
else
  echo "**** Unknown option."
fi
