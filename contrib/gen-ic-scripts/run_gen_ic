#!/bin/bash

# the number of PBE points to append to the current problem on failed candidates
NUM_PBE_PTS=10
# the maximal cardinality of a domain type of an invertibility condition
MAX_CARDINALITY=10000
# the copy of cvc4 we are using
CVC4=pr-ajr-cvc4

###############################################

# This outputs the last line in the file $1 if it contains define-fun.
# Otherwise, it reports an error.
function get_candidate()
{
  CANDIDATE=$1
  if grep -q define-fun $CANDIDATE;
  then
    # make new candidate, which is the last from the list in $CANDIDATE
    grep "define-fun" $CANDIDATE > temp.txt
    tail -1 temp.txt
    rm -f temp.txt
  else
    echo "No candidate found!"
  fi
}

# outputs the names of the declare-const variables in $1
function get_arg_list()
{
  grep "(declare-const" $1 | sed 's/(declare-const //; s/ .*/ /' 
}

# This makes a dummy candidate whose type matches the current signature,
# i.e. the __SIG line from input_problem.smt2 
function mk_dummy_candidate()
{
  echo -n "(define-fun IC " > temp.smt2
  grep "__SIG" input_problem.smt2 | sed 's/;.*//' >> temp.smt2
  echo " true)" >> temp.smt2
  tr -d '\n' < temp.smt2
  echo
  rm -f temp.smt2
}

###############################################

function mk_input_assertion()
{
  if grep -q declare-const $1;
  then
    echo "(assert (input "
    get_arg_list $1
    echo "))"
  else
    echo "(assert input)"
  fi
}

function mk_ic_assertion()
{
  if grep -q declare-const $1;
  then
    echo "(assert (IC "
    get_arg_list $1
    echo "))"
  else
    echo "(assert IC)"
  fi
}

# This generates a *.smt2 file corresponding to the invertibility condition problem.
function mk_input_problem()
{
  # the definition of the input problem
  cat $1
  mk_input_assertion $1
  echo "(check-sat)"
}

# This generates a *.smt2 file that is used to test the correctness of the
# candidate from $3 (built over the grammar in $2) on the invertibility
# condition problem from $1, whose I/O specification has been cached in $4.
function mk_input_to_test_ic_cached()
{
  # the definition of the input problem
  cat $1
  mk_input_assertion $1
  # extract definitions from the sygus grammar, which may appear in the candidate
  grep "define" $2
  # the candidate invertibility condition
  cat $3
  mk_ic_assertion $1
  # the cached I/O specification
  cat $4
  echo "(check-sat)"
}

# Same as above, without cached I/O.
function mk_input_to_test_ic()
{
  # the definition of the input problem
  cat $1
  mk_input_assertion $1
  # extract definitions from the sygus grammar, which may appear in the candidate
  grep "define" $2
  # the candidate invertibility condition
  cat $3
  mk_ic_assertion $1
  echo "(check-sat)"
}

# This generates a *.sy problem that corresponds to synthesizing the
# invertibility condition for the current approximate specification from
# $2 using the grammar from $1.
function mk_input_to_synth_ic()
{
  # must extract set-logic and sort definitions from the input problem
  grep "set-logic" $1
  grep "define-sort" $1
  # the sygus grammar
  cat $2
  # the PBE constraints
  cat $3
  echo "(check-synth)"
}

# Generate an *.smt2 corresponding to the (expanded) form of assertions
# corresponding to testing the candidate invertibility condition $1.
function mk_expand_candidate()
{
  CANDIDATE=$1
  shift
  
  # get candidate, which is the last from the list in $1
  get_candidate $CANDIDATE > temp_candidate.smt2

  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_test_ic input_problem.smt2 input_grammar.sy temp_candidate.smt2 > temp.smt2

  # test the candidate
  $CVC4 --dump=assertions --preprocess-only --default-dag-thresh=0 $@ temp.smt2
  
  # clean up
  rm -f temp_candidate.smt2
  rm -f temp.smt2
}

# Remove all temporary files generated by the workflow
function clean_temporary()
{
  rm -f temp_pbe_example_set.sy
  rm -f temp_input_to_gen_full_candidate.smt2
  rm -f temp_input_to_gen_full_spec.smt2
  rm -f temp_input_to_test_ic.smt2
  rm -f temp_input_to_eval_ic.smt2
  rm -f temp_input_to_vis_ic.smt2
  rm -f temp_input_to_synth_ic.sy
  rm -f temp-exp.smt2
  rm -f temp.smt2
}

# Clean all files for the workflow (besides full_io_spec.smt2, which is done manually)
function clean_full()
{
  clean_temporary
  
  if [ -e "full_io_spec.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: full_io_spec.smt2 already exists, remove it to continue."
  else
    # set files generated by the workflow to blank
    echo > pbe_example_set.sy
    echo > candidate_log_overall.smt2
    echo > candidate_log.smt2
    echo > input_candidates.smt2
  fi
  # TODO: remove all images?
}

function expand_candidate()
{
  mk_expand_candidate $@ > temp-exp.smt2

  # get its type
  grep "define-fun IC" temp-exp.smt2 | sed 's/Bool.*/Bool/' > temp.smt2
  # get its definition
  cat temp-exp.smt2 | grep assert | sed -n 2p | sed 's/.*assert//' >> temp.smt2
  tr -d '\n' < temp.smt2
  echo

  # clean up
  rm -f temp-exp.smt2
  rm -f temp.smt2
}

function get_signature()
{
  # make a dummy candidate
  mk_dummy_candidate > temp_sig.smt2
  
  # expand it and extract its type
  expand_candidate temp_sig.smt2 | sed 's/(define-fun IC //; s/Bool.*//'
  
  # clean up
  rm -f temp_sig.smt2
}

###############################################

# should use --gen-ic-use-eval if the satisfiability queries are difficult (takes 5-6 hours for FP(4,5))
function gen_full_io_spec()
{
  echo -n "; Full IO specification for "
  grep "__PROBLEM" input_problem.smt2 | sed 's/;.*//'
  echo -n "; with type "
  get_signature

  # generate the input problem for cvc4 to generate a full I/O specification
  mk_input_problem input_problem.smt2 > temp_input_to_gen_full_spec.smt2

  # generate the full I/O specification (takes 2-3 hours for FP(4,5))
  # notice we limit the generation of I/O tables for types whose cardinality is greater than $MAX_CARDINALITY
  $CVC4 --gen-ic-full --no-gen-ic-use-sc --fmf-type-completion-thresh=$MAX_CARDINALITY temp_input_to_gen_full_spec.smt2 $@

  # clean up
  rm -f temp_input_to_gen_full_spec.smt2
}


function gen_full_io()
{
  # make new candidate, which is the last from the list in $1
  get_candidate $1 > temp_candidate.smt2
  shift;

  # generate the input problem for cvc4 to generate a full I/O specification
  mk_input_to_test_ic input_problem.smt2 input_grammar.sy temp_candidate.smt2 > temp_input_to_gen_full_candidate.smt2

  # generate the full I/O specification for the candidate
  $CVC4 --gen-ic-full --no-gen-ic-use-sc --test-ic-full --fmf-type-completion-thresh=$MAX_CARDINALITY temp_input_to_gen_full_candidate.smt2 $@

  # clean up
  rm -f temp_input_to_gen_full_candidate.smt2
  rm -f temp_candidate.smt2
}

function visual_full_io()
{
  FULL_IO_CANDIDATE=$1;
  shift;

  mk_dummy_candidate > temp_candidate.smt2

  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_test_ic_cached input_problem.smt2 input_grammar.sy temp_candidate.smt2 $FULL_IO_CANDIDATE > temp_input_to_vis_ic.smt2

  # evaluate the candidate
  $CVC4 --gen-ic-image --gen-ic-read-io-string --fmf-type-completion-thresh=$MAX_CARDINALITY $@ temp_input_to_vis_ic.smt2

  # clean up
  rm -f temp_input_to_vis_ic.smt2
  rm -f temp_candidate.smt2
}

function generate_pbe_examples()
{
  CANDIDATE=$1;
  shift;
  
  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_test_ic_cached input_problem.smt2 input_grammar.sy $CANDIDATE full_io_spec.smt2 > temp_input_to_test_ic.smt2

  # test the candidate
  $CVC4 --test-ic-full --test-ic-gen --test-ic-random --test-ic-samples=$NUM_PBE_PTS --gen-ic-read-io-string --fmf-type-completion-thresh=$MAX_CARDINALITY $@ temp_input_to_test_ic.smt2

  # clean up
  rm -f temp_input_to_test_ic.smt2
}

function process_pbe_examples()
{
  # append the candidate we tried
  cat $1 >> candidate_log.smt2
  if grep -q constraint $2;
  then
    echo "***** Generated new counterexamples:"
    cat $2
    # add to new examples
    cat $2 >> pbe_example_set.sy
    echo "; __FAIL" >> candidate_log.smt2
  elif grep -q VERIFIED $2;
  then
    echo "***** No counterexamples for candidate!!!"
    # copy to solutions
    cat $1 >> solutions.smt2
    echo "; __VERIFY" >> candidate_log.smt2
  else
    echo "***** Internal error during testing."
    echo "; __ERROR" >> candidate_log.smt2
  fi
}

function test_candidate()
{  
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo
  
  # test the candidate, which should either generate new PBE constraints or outputs "VERIFIED"
  generate_pbe_examples temp_candidate.smt2 $@ > temp_pbe_example_set.sy
  
  # process the above output
  process_pbe_examples temp_candidate.smt2 temp_pbe_example_set.sy
  
  # clean up
  rm -f temp_candidate.smt2
  rm -f temp_pbe_example_set.sy
}

function eval_candidate()
{
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo  
  
  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_test_ic_cached input_problem.smt2 input_grammar.sy temp_candidate.smt2 full_io_spec.smt2 > temp_input_to_eval_ic.smt2

  # evaluate the candidate
  $CVC4 --test-ic-full --no-gen-ic-use-sc --gen-ic-read-io-string --fmf-type-completion-thresh=2000 temp_input_to_eval_ic.smt2

  # clean up
  rm -f temp_input_to_eval_ic.smt2
  rm -f temp_candidate.smt2
}

function quick_test_candidate()
{  
  get_candidate input_candidates.smt2  > temp_candidate.smt2
  
  # output the subject of the test (for debugging)
  cat temp_candidate.smt2
  echo
  
  # test the candidate, which should either generate new PBE constraints or outputs "VERIFIED"
  generate_pbe_examples temp_candidate.smt2 $@
  
  # clean up
  rm -f temp_candidate.smt2
}

function synth_candidate()
{
  # generate the input problem for cvc4 to test a candidate IC
  mk_input_to_synth_ic input_problem.smt2 input_grammar.sy pbe_example_set.sy > temp_input_to_synth_ic.sy

  # synthesize a new candidate
  $CVC4 --sygus-stream --sygus-pbe --output-lang=smt2 --sygus-out=status-or-def $@ temp_input_to_synth_ic.sy 2>&1 | tee input_candidates.smt2

  # we do not clean up input_candidates.smt2

  # clean up
  #rm -f temp_input_to_synth_ic.sy
}

function reset()
{
  # remove files that should be cleaned up anyways
  clean_temporary

  # append to the global candidate log if we tried any candidate
  if grep -q define-fun candidate_log.smt2;
  then
    cat candidate_log.smt2 >> candidate_log_overall.smt2
  fi
  echo > candidate_log.smt2
  # store debugging information in global candidate log
  echo "; -----------------" >> candidate_log_overall.smt2
  # append the side condition and type we were using
  echo -n "; testing with type signature: " >> candidate_log_overall.smt2
  get_signature >> candidate_log_overall.smt2
  echo -n "; testing with side condition: " >> candidate_log_overall.smt2
  grep "__SC" input_problem.smt2 | sed 's/;.*//' >> candidate_log_overall.smt2  
  
  # intialize the input candidate and the pbe examples
  echo > input_candidates.smt2
  echo > pbe_example_set.sy
  # first two candidates are trivially true, false
  # thus, these should go quickly
  echo "*** Synthesizing first initial candidate..."
  synth_candidate --no-sygus-stream
  echo "***** Testing first initial candidate:"
  test_candidate
  echo "*** Synthesizing second initial candidate..."
  synth_candidate --no-sygus-stream
  echo "***** Testing second initial candidate:"
  test_candidate
}


###############################################


if [ X$1 = X'-reset' ]; 
then
  shift;
  reset $@
  echo
  echo "*** Synthesis environment initialized. Now, run alternating calls to:"
  echo "  run_gen_ic -synth"
  echo "  run_gen_ic -test"
elif [ X$1 = X'-synth' ]; 
then
  shift;
  echo "*** Synthesizing candidates..."
  synth_candidate $@
elif [ X$1 = X'-test' ]; 
then
  shift;
  echo "***** Testing candidate:"
  test_candidate $@
elif [ X$1 = X'-testfull' ]; 
then
  shift;
  echo "***** Testing candidate on all inputs:"
  echo ";;; __FULL" >> candidate_log.smt2
  test_candidate $@ --no-gen-ic-use-sc
  echo ";;;" >> candidate_log.smt2
elif [ X$1 = X'-quicktest' ]; 
then
  shift;
  # test without logging or buffering
  echo "***** Quick test candidate:"
  quick_test_candidate $@
elif [ X$1 = X'-gen' ]; 
then
  shift;
  # generate the full i/o behavior of $1, which a file containing define-fun.
  gen_full_io $@
elif [ X$1 = X'-genspec' ]; 
then
  shift;
  # Generate the full i/o behavior of the input problem
  # This option is useful for "continuing" the generation of a I/O bitstring,
  # in the case of an abnormal termination.
  gen_full_io_spec $@
elif [ X$1 = X'-visual' ]; 
then
  shift;
  # visualize the full i/o behavior of $1, which is an I/O bitstring table.
  visual_full_io $@
elif [ X$1 = X'-expand' ]; 
then
  shift;
  expand_candidate $@
elif [ X$1 = X'-simplify' ]; 
then
  shift;
  expand_candidate $@ --ext-rew-prep --ext-rew-prep-agg
elif [ X$1 = X'-eval' ]; 
then
  shift;
  echo "***** Evaluating candidate:"
  eval_candidate $@
elif [ X$1 = X'-clean' ]; 
then
  shift;
  # clear all auxiliary files except for full_io_spec.smt2
  clean_full
elif [ X$1 = X'-arglist' ];
then
  shift;
  get_arg_list $1
elif [ X$1 = X'-setup' ]; 
then
  shift;
  # Note: only call -setup once per problem
  if [ -e "full_io_spec.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: full_io_spec.smt2 already exists, remove it to continue."
  else
    # clear all auxiliary files
    clean_full
    echo "***** Compute full input/output specification for invertibility condition based on the input problem..."
    gen_full_io_spec $@ 2>&1 | tee full_io_spec.smt2
  fi
elif [ X$1 = X'-run' ]; 
then
  shift;
  if [ -e "solutions.smt2" ];
  then
    # We are very careful not to overwrite full_io_spec.smt2
    echo "*** ABORT: solutions.smt2 already exists, remove it to continue."
  else
    reset
    while [ ! -e  "solutions.smt2" ]
    do
      echo "*** Synthesizing candidates..."
      synth_candidate --no-sygus-stream
      echo "***** Testing candidate:"
      test_candidate
    done
  fi
else
  echo "**** Unknown option."
fi
