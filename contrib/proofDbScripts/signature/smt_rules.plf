
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CNF Clausification
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; binding between an LF var and an (atomic) formula

(declare atom (! v var (! p (term Bool) type)))

; binding between two LF vars
(declare bvatom (! sat_v var (! bv_v var type)))

(declare decl_atom
  (! f (term Bool)
  (! u (! v var
       (! a (atom v f)
         (holds cln)))
    (holds cln))))

;; declare atom enhanced with mapping
;; between SAT prop variable and BVSAT prop variable
(declare decl_bvatom
  (! f (term Bool)
  (! u (! v var
       (! bv_v var
       (! a (atom v f)
       (! bva (atom bv_v f)
       (! vbv (bvatom v bv_v)
         (holds cln))))))
    (holds cln))))


; clausify a formula directly
(declare clausify_form
  (! f (term Bool)
  (! v var
  (! a (atom v f)
  (! u (th_holds f)
    (holds (clc (pos v) cln)))))))

(declare clausify_form_not
  (! f (term Bool)
  (! v var
  (! a (atom v f)
  (! u (th_holds (not f))
    (holds (clc (neg v) cln)))))))

(declare clausify_false
  (! u (th_holds false)
    (holds cln)))

(declare th_let_pf
  (! f (term Bool)
  (! u (th_holds f)
  (! u2 (! v (th_holds f) (holds cln))
    (holds cln)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Natural deduction rules : used for CNF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; contradiction

(declare contra
  (! f (term Bool)
  (! r1 (th_holds f)
  (! r2 (th_holds (not f))
    (th_holds false)))))

; truth
(declare truth (th_holds true))

;; not not

(declare not_not_intro
  (! f (term Bool)
  (! u (th_holds f)
    (th_holds (not (not f))))))

(declare not_not_elim
  (! f (term Bool)
  (! u (th_holds (not (not f)))
    (th_holds f))))

;; or elimination

(declare or_elim_1
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (not f1))
  (! u2 (th_holds (or f1 f2))
    (th_holds f2))))))

(declare or_elim_2
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (not f2))
  (! u2 (th_holds (or f1 f2))
    (th_holds f1))))))

(declare not_or_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u2 (th_holds (not (or f1 f2)))
    (th_holds (and (not f1) (not f2)))))))

;; and elimination

(declare and_elim_1
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u (th_holds (and f1 f2))
    (th_holds f1)))))

(declare and_elim_2
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u (th_holds (and f1 f2))
    (th_holds f2)))))

(declare not_and_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u2 (th_holds (not (and f1 f2)))
    (th_holds (or (not f1) (not f2)))))))

;; impl elimination

(declare impl_intro (! f1 (term Bool)
                    (! f2 (term Bool)
                    (! i1 (! u (th_holds f1)
                              (th_holds f2))
                      (th_holds (=> f1 f2))))))

(declare impl_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u2 (th_holds (=> f1 f2))
    (th_holds (or (not f1) f2))))))

(declare not_impl_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u (th_holds (not (=> f1 f2)))
    (th_holds (and f1 (not f2)))))))

;; iff elimination

(declare iff_elim_1
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (= Bool f1 f2))
    (th_holds (or (not f1) f2))))))

(declare iff_elim_2
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (= Bool f1 f2))
    (th_holds (or f1 (not f2)))))))

(declare not_iff_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u2 (th_holds (not (= Bool f1 f2)))
    (th_holds (= Bool f1 (not f2)))))))

; xor elimination

(declare xor_elim_1
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (xor f1 f2))
    (th_holds (or (not f1) (not f2)))))))

(declare xor_elim_2
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u1 (th_holds (xor f1 f2))
    (th_holds (or f1 f2))))))

(declare not_xor_elim
  (! f1 (term Bool)
  (! f2 (term Bool)
  (! u2 (th_holds (not (xor f1 f2)))
    (th_holds (iff f1 f2))))))

;; ite elimination

(declare ite_elim_1
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (ite Bool a b c))
    (th_holds (or (not a) b)))))))

(declare ite_elim_2
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (ite Bool a b c))
    (th_holds (or a c)))))))

(declare ite_elim_3
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (ite Bool a b c))
    (th_holds (or b c)))))))

(declare not_ite_elim_1
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (not (ite Bool a b c)))
    (th_holds (or (not a) (not b))))))))

(declare not_ite_elim_2
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (not (ite Bool a b c)))
    (th_holds (or a (not c))))))))

(declare not_ite_elim_3
  (! a (term Bool)
  (! b (term Bool)
  (! c (term Bool)
  (! u2 (th_holds (not (ite Bool a b c)))
    (th_holds (or (not b) (not c))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; For theory lemmas
; - make a series of assumptions and then derive a contradiction (or false)
; - then the assumptions yield a (term Bool) like "v1 -> v2 -> ... -> vn -> false"
; - In CNF, it becomes a clause: "~v1, ~v2, ..., ~vn"
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare ast
  (! v var
  (! f (term Bool)
  (! C clause
  (! r (atom v f)       ;this is specified
  (! u (! o (th_holds f)
         (holds C))
    (holds (clc (neg v) C))))))))

(declare asf
  (! v var
  (! f (term Bool)
  (! C clause
  (! r (atom v f)
  (! u (! o (th_holds (not f))
         (holds C))
    (holds (clc (pos v) C))))))))

;; Numeric primitives

(program mpz_sub ((x mpz) (y mpz)) mpz
	 (mp_add x (mp_mul (~1) y)))

(program mp_ispos ((x mpz)) term
	 (mp_ifneg x false true))

(program mpz_eq ((x mpz) (y mpz)) term
    (mp_ifzero (mpz_sub x y) true false))

(program mpz_lt ((x mpz) (y mpz)) term
    (mp_ifneg (mpz_sub x y) true false))

(program mpz_lte ((x mpz) (y mpz)) term
    (mp_ifneg (mpz_sub x y) true (mpz_eq x y)))

;; Example:
;;
;; Given theory literals (F1....Fn), and an input formula A of the form (th_holds (or F1 (or F2 .... (or F{n-1} Fn))))).
;;
;; We introduce atoms (a1,...,an) to map boolean literals (v1,...,vn) top literals (F1,...,Fn).
;; Do this at the beginning of the proof:
;;
;; (decl_atom F1 (\ v1 (\ a1
;; (decl_atom F2 (\ v2 (\ a2
;; ....
;; (decl_atom Fn (\ vn (\ an
;;
;;  A is then clausified by the following proof:
;;
;;(satlem _ _
;;(asf _ _ _ a1 (\ l1
;;(asf _ _ _ a2 (\ l2
;;...
;;(asf _ _ _ an (\ ln
;;(clausify_false
;;
;;   (contra _
;;      (or_elim_1 _ _ l{n-1}
;;	...
;;      (or_elim_1 _ _ l2
;; 	(or_elim_1 _ _ l1 A))))) ln)
;;
;;))))))) (\ C
;;
;; We now have the free variable C, which should be the clause (v1 V ... V vn).
;;
;; Polarity of literals should be considered, say we have A of the form (th_holds (or (not F1) (or F2 (not F3)))).
;; Where necessary, we use "ast" instead of "asf", introduce negations by "not_not_intro" for pattern matching, and flip
;; the arguments of contra:
;;
;;(satlem _ _
;;(ast _ _ _ a1 (\ l1
;;(asf _ _ _ a2 (\ l2
;;(ast _ _ _ a3 (\ l3
;;(clausify_false
;;
;;   (contra _ l3
;;      (or_elim_1 _ _ l2
;; 	(or_elim_1 _ _ (not_not_intro l1) A))))
;;
;;))))))) (\ C
;;
;; C should be the clause (~v1 V v2 V ~v3 )
