======================== Theory

In the current architecture, a Theory maintains:
(1) Valuation class, for basic queries about the state of the TheoryEngine.
(2) OutputChannel for sending lemmas/conflicts.
(3) (Optionally) EqualityEngine.

In the new architecture, Theory *must* denote its "official" equality engine
(which is highly recommended but not required), which will be used to
standardize various behaviors of the Theory and to provide a default behavior
for its role in theory combination. 

Notes:
- arith and (lazy) bv use equality engines, albeit in highly specialized ways.
These theories can continue to use these custom methods but should be
progressively refactored to conform to the new standard architecture.
- quantifiers, boolean, builtin do not require equality engines.
- All other theories use equality engines in roughly a standard way.

A Theory should not use (1) and (2) directly, and instead use the following two
classes that wrap Valuation/OutputChannel respectively, while also considering
the EqualityEngine:

(4) SolverState, which references:
* Valuation, which forwards basic queries.
* EqualityEngine, for methods getRepresentative, hasTerm, areEqual, etc.
* Methods for "inConflict", "hasSentLemma", "hasAddedInternalFact", etc.

(5) InferenceManager, which manages whether derived conclusions should:
* Be sent as "facts" to EqualityEngine via assertEquality, assertPredicate, etc.
* Be sent as "lemmas" via OutputChannel.
InferenceManager references SolverState and should have a standard effect on it
(e.g. mark "inConflict" in SolverState if OutputChannel::conflict was called).

======== Standard callbacks during check:

The `check` method of Theory is recommended to be a fixed template.
Theory must implement these methods:
```
// prior to processing fact queue
virtual bool preCheck(Effort level = EFFORT_FULL);
// after processing fact queue
virtual void postCheck(Effort level = EFFORT_FULL);
// called when a fact is taken from queue
virtual bool preNotifyFact(TNode atom, bool polarity, TNode fact);
// called after a fact is taken from queue and asserted to equality engine
virtual void notifyFact(TNode atom, bool polarity, TNode fact, bool isInternal);
```
Notice that additionally each theory may optionally implement equality engine
callbacks, which are lower level:
```
// when a new equivalence class is created
void eqNotifyNewClass(TNode t);
// when two equivalence classes are merged
void eqNotifyMerge(TNode t1, TNode t2);
// when two equivalence classes become disequal
void eqNotifyDisequal(TNode t1, TNode t2, TNode reason);
```
This is in addition to three standard equality engine callbacks
(eqNotifyTriggerPredicate, eqNotifyTriggerTermEquality, and 
eqNotifyConstantTermMerge) which have a fixed behavior for each theory.

======== Standard collect model info method:

The `collectModelInfo` method of Theory is recommended to be a fixed template.
Theory must implement these methods:
```
virtual bool collectModelValues(TheoryModel* m, const std::set<Node>& termSet);
virtual void computeRelevantTerms(std::set<Node>& termSet);
```

======================== TheoryEngine

In the current architecture TheoryEngine maintains:
(1) (Multiple) Theory objects.
(2) QuantifiersEngine.
(3) Methods that manage propagations between theories and how to explain lemmas.
(4) Pointer to PropEngine.
(5) CombinationEngine
This class is responsible for running the theory combination method. The current
implementation would be called CombinationEngineCareGraph and derive from the
abstract class. A future implementation would be called
CombinationEngineModelBased. This class maintains:
(5.1) EqualityEngineManager, which decides which equality engines are assigned
to Theory.  The current implementation would be called
EqualityEngineManagerDistributed, which assigns unique equality engines to each
theory. A future implementation would be called EqualityEngineManagerCentral,
for assigning the same equality engine to all theories.
(5.2) ModelManager, which manages the model in a way that is compatible with
the combination method. The current implementation would be called
ModelManagerDistributed (since the model maintains its own equality engine).
(5.3) SharedSolver, which manages theory-wide propagation/explanation
methods, and is responsible for ensuring Theory::addSharedTerm is called.
The class SharedTermsDatabase acts as the shared solver in the current
architecture.

Overall, the goal is to update Theory to use standard interfaces to
EqualityEngine/SolverState/InferenceManager so that the theory combination
mechanism can be made flexible. For instance, equality engines can be
configured by the TheoryCombination mechanism to behave differently and as
appropriate if the theory combination method is modified.




