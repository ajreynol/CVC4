#include "cvc4_private.h"

#ifndef __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H
#define __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H

#include "theory/theory.h"

namespace CVC4 {
namespace theory {
namespace sample {

/**
 * 
 * This theory solver operates under a different semantics than typical
 * theory solvers, which is based on the notion of a "sample run" as described
 * below.
 * 
 * This theory has a notion of "sample type". We associate sample types with a
 * context-free term grammar, which will determine the semantics of the type.
 * All other types we call ordindary types.
 * 
 * For example, consider a sample type SampleInt that is associated with the
 * grammar:
 *   SampleInt -> 0 | 1 | x | f( SampleInt )
 * Roughly, terms of type SampleInt are interpreted as either 0, 1, x,
 * f( SampleInt ), where x : Int and f : Int -> Int.
 * 
 * In detail, a "base sample term" is a term of the form (f c1 ... cn) whose
 * return type is a sample type, and c1...cn are constant terms whose type is
 * ordinary.
 *
 * Given an interpretation M for all functions whose return type is not a sample
 * type, a "sample run" for M is an extension of M where all base sample terms t
 * are interpreted as r^M, where r is a random term generated by the context
 * free grammar associated with its sample type.
 * 
 * Consider the SampleInt example above, and an interpretation M where 
 * x^M = 7 and f^M = lambda y. 10. In a sample run of M, the value of s^M
 * is determined by generating a random term in the SampleInt grammar, 
 * say f( x ). Then s^M = f( x )^M = 10.
 * 
 * This theory solver is used in part to answer satisfiability checks that
 * are parameterized by:
 * (1) #runs (--num-samples),
 * (2) #sat-runs (--num-samples-sat).
 * 
 * A formula F is satisfied by an interpretation M iff F evaluates to true
 * in at least #sat-runs out of #runs sample runs. Notice that this semantics is
 * non-deterministic: the same check may produce "sat" and "unsat" on different
 * runs.
 * 
 * Notice the restriction that functions with sample return type cannot take
 * arguments with sample types.
 */
class TheorySample : public Theory
{
  typedef context::CDHashSet<Node, NodeHashFunction> NodeSet;

 public:
  /** Constructs a new instance of TheorySample w.r.t. the provided contexts. */
  TheorySample(context::Context* c,
               context::UserContext* u,
               OutputChannel& out,
               Valuation valuation,
               const LogicInfo& logicInfo);

  void check(Effort) override;

  std::string identify() const override { return "THEORY_SAMPLE"; }
  /** needs check last effort */
  bool needsCheckLastEffort() override;
  /** finish init */
  void finishInit() override;

 private:
  /** common nodes */
  Rational d_rmax;
  Node d_true;

  NodeSet d_not_elim;
  NodeSet d_sample_checks;
  /** number of samples */
  unsigned d_num_samples;
  /** number of samples we allow to be not sat */
  unsigned d_num_samples_nsat;
  /** whether a term is a sampling term */
  std::map<Node, bool> d_isSample;
  /** whether a term has sampling subterms */
  std::map<Node, bool> d_hasSample;
  /** assertion information */
  class AssertInfo
  {
   public:
    /** free terms */
    std::vector<Node> d_free_terms;
    /** sample terms */
    std::vector<Node> d_sample_terms;
    /** sample terms */
    std::vector<TypeNode> d_sample_term_types;
    /** init */
    void init() {}
  };
  std::map<Node, AssertInfo> d_ainfo;

  class TypeInfo
  {
   public:
    Node d_value;
    unsigned d_ncons;
    std::vector<bool> d_builtin;
    std::vector<Node> d_ops;
    std::vector<Kind> d_kinds;
    std::vector<std::vector<TypeNode> > d_args;
    /** for random calls */
    std::vector<unsigned> d_rmin;
    std::vector<unsigned> d_rmax;
    /** init */
    void init() {}
  };
  std::map<TypeNode, TypeInfo> d_tinfo;

  /** register sample check constraint */
  void registerSampleCheck(Node n);

  /** register sample term */
  void registerSampleType(TypeNode tn);

  /** check last call */
  void checkLastCall();
  /** check */
  bool runCheck();
  /** the master equality engine (used for explainations */
  eq::EqualityEngine* d_masterEe;
  /** explain model value */
  Node explainModelValue(Node n, std::vector<Node>& vec);

  //-------------------------per last call effort check
  std::vector<Node> d_asserts;
  std::vector<Node> d_basserts;
  std::map<Node, std::map<unsigned, Node> > d_assert_to_value;
  /** get base model value
   *
   * This function returns a term where all non-sampling operators have been
   * replaced by their value in the current model.
   */
  Node getBaseModelValue(Node n);
  /** cache of the above function */
  std::unordered_map<Node, Node, NodeHashFunction> d_bmv;
  /** base sampling terms for this round */
  std::vector<Node> d_base_sample_terms;
  /** conflict */
  std::unordered_set<Node, NodeHashFunction> d_conflict;
  //-------------------------end per last call effort check

  /** get sample value 
   * 
   * Returns a random term, given sampling datatype type tn.
   */
  Node mkSampleValue(TypeNode tn);
  /** cache of the sampling
   * 
   * Each entry d_bst_to_terms[i][ba] stores the result of the random term
   * generator for base sample term ba on sample point i.
   */
  std::map<unsigned, std::map<Node, Node> > d_bst_to_terms;
}; /* class TheorySample */

}  // namespace sample
}  // namespace theory
}  // namespace CVC4

#endif /* __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H */
