#include "cvc4_private.h"

#ifndef __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H
#define __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H

#include "theory/theory.h"

#include "theory/evaluator.h"
#include "theory/quantifiers/term_database.h"

namespace CVC4 {
namespace theory {
namespace sample {

/**
 *
 * This theory solver operates under a different semantics than typical
 * theory solvers, which is based on the notion of a "sample run" as described
 * below.
 *
 * First, this theory has a notion of "sample type". We associate sample types
 * with a context-free term grammar, which will determine the semantics of the
 * type. All other types we call ordindary types.
 *
 * For example, consider a sample type SampleInt that is associated with:
 *   SampleInt -> 0 | 1 | x | f( SampleInt )
 * Roughly, terms of type SampleInt are interpreted as either 0, 1, x, or
 * f( u ) for some term u of type SampleInt, where x : Int and f : Int -> Int.
 *
 * In detail, a "base sample term" is a term of the form op(c1 ... cn) whose
 * return type is a sample type, and c1, ..., cn are constant terms whose type
 * is ordinary.
 *
 * Given an interpretation M for all functions whose return type is not a sample
 * type, a "sample run" for M is an extension of M where all base sample terms t
 * are interpreted as r^M, where r is a random term generated by the context
 * free grammar associated with its sample type.
 *
 * Consider the SampleInt example above, and an interpretation M where
 * x^M = 7 and f^M = lambda y. ite( y=7, 10, 0 ). In a sample run of M, the
 * value of s^M is determined by generating a random term in the SampleInt
 * grammar, say f( x ). Then s^M = f( x )^M = 10.
 *
 * This theory solver is used in part to answer satisfiability checks that
 * are parameterized by:
 * (1) #runs (--num-samples),
 * (2) #sat-runs (--num-samples-sat).
 *
 * A formula F is satisfied by an interpretation M iff F evaluates to true
 * in at least #sat-runs out of #runs sample runs. Notice that this semantics is
 * non-deterministic, the same check may produce "sat" and "unsat" on different
 * runs.
 *
 * Notice the restriction that functions with sample return type cannot take
 * arguments with sample types.
 */
class TheorySample : public Theory
{
  typedef context::CDHashSet<Node, NodeHashFunction> NodeSet;

 public:
  /** Constructs a new instance of TheorySample w.r.t. the provided contexts. */
  TheorySample(context::Context* c,
               context::UserContext* u,
               OutputChannel& out,
               Valuation valuation,
               const LogicInfo& logicInfo);

  void check(Effort) override;

  std::string identify() const override { return "THEORY_SAMPLE"; }
  /** needs check last effort */
  bool needsCheckLastEffort() override;
  /** finish init */
  void finishInit() override;
  /** preregister term */
  void preRegisterTerm(TNode n) override;

 private:
  /** common nodes */
  Rational d_rmax;
  Node d_true;
  /** an evaluator object */
  Evaluator d_eval;

  NodeSet d_not_elim;
  NodeSet d_sample_checks;
  /** number of samples */
  unsigned d_num_samples;
  /** number of samples we allow to be not sat */
  unsigned d_num_samples_nsat_allow;
  /** the set of terms that are sampling terms */
  std::unordered_set<Node, NodeHashFunction> d_isSample;
  /** whether a term has sampling subterms */
  std::map<Node, bool> d_hasSample;
  /** assertion information */
  class AssertInfo
  {
   public:
    /** free terms */
    std::vector<Node> d_free_terms;
    /** sample terms */
    std::vector<Node> d_sample_terms;
    /** sample terms */
    std::vector<TypeNode> d_sample_term_types;
    /** init */
    void init() {}
  };
  std::map<Node, AssertInfo> d_ainfo;

  class TypeInfo
  {
   public:
    Node d_value;
    unsigned d_ncons;
    std::vector<bool> d_builtin;
    std::vector<Node> d_ops;
    std::vector<Kind> d_kinds;
    std::vector<std::vector<TypeNode> > d_args;
    /** for random calls */
    std::vector<unsigned> d_rmin;
    std::vector<unsigned> d_rmax;
    /** init */
    void init() {}
  };
  std::map<TypeNode, TypeInfo> d_tinfo;

  /** register sample check constraint */
  void registerSampleCheck(Node n);

  /** register sample term */
  void registerSampleTerm(Node n,
                          std::vector<Node>& freeTerms,
                          std::vector<Node>& sampleTerms);

  /** register sample term */
  void registerSampleType(TypeNode tn);

  /** check last call */
  void checkLastCall();
  /** check */
  bool runCheck();
  /** number of samples that were not SAT */
  unsigned d_nsat_count;
  //-------------------------conflict explanation
  /** term index (built at last call) */
  std::map<Node, quantifiers::TermArgTrie> d_tindex;
  /** compute the term index */
  void computeTermIndex();
  /** get congruent term */
  Node getCongruentTerm(Node op, std::vector<TNode>& args);
  /** the master equality engine (used for explainations */
  eq::EqualityEngine* d_masterEe;
  /** explain model value */
  Node explainModelValue(Node n, std::vector<Node>& vec, unsigned ind = 0);
  //-------------------------end conflict explanation

  //-------------------------per last call effort check
  /** the assertions of kind SAMPLE_CHECK */
  std::vector<Node> d_asserts;
  /**
   * The "base" assertion forms of each of the above assertions. This is a
   * literal where each non-sample term is replaced by its model value.
   */
  std::vector<Node> d_basserts;
  std::map<Node, std::map<unsigned, Node> > d_assert_to_value;
  /** get base model value
   *
   * This function returns a term where all non-sampling operators have been
   * replaced by their value in the current model.
   */
  Node getBaseModelValue(Node n);
  /** cache of the above function */
  std::unordered_map<Node, Node, NodeHashFunction> d_bmv;
  /** base sampling terms for this round */
  std::vector<Node> d_base_sample_terms;
  /** conflict */
  std::unordered_set<Node, NodeHashFunction> d_conflict;
  //-------------------------end per last call effort check

  /** get sample value
   *
   * Returns a random term, given sampling datatype type tn.
   */
  Node mkSampleValue(TypeNode tn);
  /** free variables for base sample terms */
  std::map<Node, Node> d_bst_to_fv;
  /** cache of the sampling
   *
   * Each entry d_sample_bst_to_terms[i][ba] stores the result of the random
   * termgenerator for base sample term ba on sample point i.
   */
  std::map<unsigned, std::map<Node, Node> > d_sample_bst_to_terms;
  /** cache
   *
   * Each entry d_bst_term_to_samples[ba][t] stores the sample indices
   * j1...jn for which d_sample_bst_to_terms[ji][ba] = t.
   */
  std::map<Node, std::map<Node, std::vector<unsigned> > > d_bst_term_to_samples;
  /**
   * Each d_bst_to_nconst_terms[ba] the list of non-constant terms t1...tk in
   * the domain of d_bst_term_to_samples[ba].
   */
  std::map<Node, std::vector<Node> > d_bst_to_nconst_terms;
}; /* class TheorySample */

}  // namespace sample
}  // namespace theory
}  // namespace CVC4

#endif /* __CVC4__THEORY__SAMPLE__THEORY_SAMPLE_H */
