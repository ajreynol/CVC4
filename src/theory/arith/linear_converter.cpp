/******************************************************************************
 * Top contributors (to current version):
 *   Andrew Reynolds, Alex Ozdemir, Tim King
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Implementation of common functions for dealing with nodes.
 */

#include "theory/arith/linear_converter.h"

#include "expr/attribute.h"
#include "smt/env.h"
#include "theory/rewriter.h"

namespace cvc5::internal {
namespace theory {
namespace arith {

struct ToPrivateAttributeId
{
};
typedef expr::Attribute<ToPrivateAttributeId, Node> ToPrivateAttribute;

struct FromPrivateAttributeId
{
};
typedef expr::Attribute<FromPrivateAttributeId, Node> FromPrivateAttribute;

Node convertToArithPrivate(Env& env, TNode n)
{
  if (n.getKind()==kind::ARITH_EQ)
  {
    return n;
  }
  ToPrivateAttribute tpa;
  if (n.hasAttribute(tpa))
  {
    return n.getAttribute(tpa);
  }
  Node ret = n;
  Kind k = n.getKind();
  // note k could ne ARITH_EQ, e.g. for internal entailment checks
  if (k == kind::TO_REAL)
  {
    Assert(n[0].getKind() != kind::TO_REAL);
    ret = n[0];
  }
  else if (k == kind::NOT)
  {
    Node cn = convertToArithPrivate(env, n[0]);
    if (cn != n[0])
    {
      ret = cn.notNode();
    }
  }
  if (k == kind::EQUAL)
  {
    TNode left = n[0].getKind() == kind::TO_REAL ? n[0][0] : n[0];
    TNode right = n[1].getKind() == kind::TO_REAL ? n[1][0] : n[1];
    ret = NodeManager::currentNM()->mkNode(kind::ARITH_EQ, left, right);
  }
  if (ret != n)
  {
    ret = env.getRewriter()->rewrite(ret);
    FromPrivateAttribute fpa;
    ret.setAttribute(fpa, n);
    Trace("arith-private-debug") << "ToPrivate: " << n << " -> " << ret << std::endl;
  }
  n.setAttribute(tpa, ret);
  return ret;
}

Node convertFromArithPrivate(TNode n)
{
  FromPrivateAttribute fpa;
  if (n.hasAttribute(fpa))
  {
    // if we were the result of converting an existing equality, use it
    return n.getAttribute(fpa);
  }
  if (n.getKind()==kind::NOT)
  {
    Node cn = convertFromArithPrivate(n[0]);
    if (cn != n[0])
    {
      return cn.notNode();
    }
  }
  Assert (n.getKind()!=kind::ARITH_EQ);
  return n;
}

Node convertFromArithPrivate(Env& env, TNode n)
{
  FromPrivateAttribute fpa;
  if (n.hasAttribute(fpa))
  {
    // if we were the result of converting an existing equality, use it
    Node ret = n.getAttribute(fpa);
    Assert (ret.getKind()!=kind::ARITH_EQ);
    return ret;
  }
  Kind k = n.getKind();
  if (k==kind::NOT)
  {
    Node cn = convertFromArithPrivate(env, n[0]);
    if (cn != n[0])
    {
      return cn.notNode();
    }
  }
  else if (k==kind::ARITH_EQ)
  {
    // otherwise, this is a new literal generated by some code within
    // arithmetic theory. We convert to a properly typed equality here.
    NodeManager * nm = NodeManager::currentNM();
    TypeNode tn[2];
    for (size_t i = 0; i<2; i++)
    {
      tn[i] = n[i].getType();
    }
    std::vector<Node> children(n.begin(), n.end());
    // cast one side to real if necessary
    if (tn[0]!=tn[1])
    {
      size_t indexCast = tn[0].isInteger() ? 0 : 1;
      children[indexCast] = nm->mkNode(kind::TO_REAL, children[indexCast]);
    }
    Node ret = nm->mkNode(kind::EQUAL, children);
    ret = env.getRewriter()->rewrite(ret);
    return ret;
  }
  return n;
}

FromArithPrivateConverter::FromArithPrivateConverter(Env& env) : EnvObj(env) {}

Node FromArithPrivateConverter::postConvert(Node n)
{
  return convertFromArithPrivate(d_env, n);
}

}  // namespace arith
}  // namespace theory
}  // namespace cvc5::internal
