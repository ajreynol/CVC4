(set-logic ALL)
;;; options
(set-option :sampling true)
(set-option :num-samples 10000)
(set-option :num-samples-sat 2400)

;;;  We have 4 Nodes (A,B,C,D)
(declare-datatype Node ((A) (B) (C) (D)))

;;; This maps edges to a value [0...1000], where conceptually 0 means not connected and 1000 means fully connected.
(declare-fun edge (Node Node) Int)
(assert (= (edge A A) 0))
(assert (= (edge A D) 0))
(assert (= (edge D D) 0))
(assert (= (edge A B) 750))
(assert (= (edge A C) 500))
(assert (= (edge B D) 100))
(assert (= (edge C D) 500))

;;; A "sampling type" which defines a random (integer) expression generator.
(declare-sample-sort UnifInt Int
  (
    ;;;; The expressions generated by this grammar are uniformly distributed integers in the range [0...1000]
    (Start Int ((sample.int.unif 0 1000)))
  )
)
;;; A sampling function for each edge.
(declare-fun random (Node Node) UnifInt)
;;; A predicate that holds for (x,y) with probability N/1000 where N is the weight of (edge x y).
;;; For example, (checkEdge A B) holds with probability 75%.
(define-fun checkEdge ((x Node) (y Node)) Bool (> (edge x y) (sample.run (random x y))))

;;; Find a Node x that A connects to, and connects to D.
(declare-fun x () Node)
(assert (checkEdge A x))
(assert (checkEdge x D))

;;; Given num-samples (10000) declared above, we require a model (value for x) for which the above 2 assertions hold at least 2400 times.
(check-sat)
