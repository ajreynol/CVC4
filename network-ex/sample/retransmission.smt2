(set-logic ALL)
;;; options
(set-option :sampling true)
(set-option :num-samples 1000)
(set-option :num-samples-sat 900)

;;;  We have 4 Nodes (A,B,C,D)
(declare-datatype Node ((A) (B) (C) (D)))

;;; This maps edges to a value [0...1000], where conceptually 0 means not connected and 1000 means fully connected.
(declare-fun edge (Node Node) Int)
(assert (= (edge A B) 750))

;;; A "sampling type" which defines a random (integer) expression generator.
(declare-sample-sort UnifInt Int
  (
    ;;;; The expressions generated by this grammar are uniformly distributed integers in the range [0...1000]
    (Start Int ((sample.int.unif 0 1000)))
  )
)
;;; A sampling function for each edge.
(declare-fun random (Node Node Int) UnifInt)
;;; A predicate that holds for (x,y) with probability N/1000 where N is the weight of (edge x y).
;;; For example, (checkEdge A B) holds with probability 75%.
(define-fun checkEdge ((x Node) (y Node) (t Int)) Bool (> (edge x y) (sample.run (random x y t))))



;; Testing retransmissions

(declare-fun num_retransmit () Int)
(assert (>= num_retransmit 0))

(declare-fun transmitAB (Int) Bool)

(assert (not (transmitAB 0)))

(assert (forall ((t Int)) (=> 
  (and (<= 0 t) (< t num_retransmit)) 
  (= (transmitAB (+ t 1)) (or (transmitAB t) (checkEdge A B t)))
)))

(assert (transmitAB num_retransmit))


;(assert (= (transmitAB 2) (or (checkEdge A B 0) (checkEdge A B 1))))

;(assert (transmitAB 2))
;(assert (= num_retransmit 

(check-sat)
