(set-logic DTLIRA)

(declare-datatype Node ((A) (B) (C) (D)))


; pA is a function of the form (lambda abcd. t),
; where the term t must be generated by the grammar "Start":
;   Start -> B | C | D | ite( StartCond, Start, Start )
;   StartCond -> a | b | c | d | not( StartCond )
; 
(synth-fun pA ((a Bool) (b Bool) (c Bool) (d Bool)) Node
  (
   (Start Node (
     B
     C 
     D
     (ite StartCond Start Start)
   ))
   (StartCond Bool (     
      a b c d
     (not StartCond)
   ))
))

; pB is a function of the form (lambda abcd. t),
; where the term t must be generated by the grammar "Start":
;   Start -> A | C | D | ite( StartCond, Start, Start )
;   StartCond -> a | b | c | d | not( StartCond )
; 
(synth-fun pB ((a Bool) (b Bool) (c Bool) (d Bool)) Node
  (
   (Start Node (
     A
     C 
     D
     (ite StartCond Start Start)
   ))
   (StartCond Bool (     
      a b c d
     (not StartCond)
   ))
))

; pC is a function of the form (lambda abcd. t),
; where the term t must be generated by the grammar "Start":
;   Start -> A | B | D | ite( StartCond, Start, Start )
;   StartCond -> a | b | c | d | not( StartCond )
; 
(synth-fun pC ((a Bool) (b Bool) (c Bool) (d Bool)) Node
  (
   (Start Node (
     A
     B
     D
     (ite StartCond Start Start)
   ))
   (StartCond Bool (     
      a b c d
     (not StartCond)
   ))
))

; pD is a function of the form (lambda abcd. t),
; where the term t must be generated by the grammar "Start":
;   Start -> A | B | C | ite( StartCond, Start, Start )
;   StartCond -> a | b | c | d | not( StartCond )
; 
(synth-fun pD ((a Bool) (b Bool) (c Bool) (d Bool)) Node
  (
   (Start Node (
     A
     B
     C
     (ite StartCond Start Start)
   ))
   (StartCond Bool (     
      a b c d
     (not StartCond)
   ))
))

; transition relation T
(define-fun T ((transA Bool) (transB Bool) (transC Bool) (transD Bool) (transAp Bool) (transBp Bool) (transCp Bool) (transDp Bool)) Bool
(and
  (= transA transAp)
  (= (or transB (and transA (= (pA transA transB transC transD) B) (= (pB transA transB transC transD) A))) transBp)
  (= (or transC (and transB (= (pB transA transB transC transD) C) (= (pC transA transB transC transD) B))) transCp)
  (= (or transD (and transC (= (pC transA transB transC transD) D) (= (pD transA transB transC transD) C))) transDp)
))

; initial
(synth-fun transA0 () Bool)
(synth-fun transB0 () Bool)
(synth-fun transC0 () Bool)
(synth-fun transD0 () Bool)
(constraint transA0)
(constraint (not transB0))
(constraint (not transC0))
(constraint (not transD0))

; unfold 1
(synth-fun transA1 () Bool)
(synth-fun transB1 () Bool)
(synth-fun transC1 () Bool)
(synth-fun transD1 () Bool)
(constraint (T transA0 transB0 transC0 transD0 transA1 transB1 transC1 transD1))


; unfold 2
(synth-fun transA2 () Bool)
(synth-fun transB2 () Bool)
(synth-fun transC2 () Bool)
(synth-fun transD2 () Bool)
(constraint (T transA1 transB1 transC1 transD1 transA2 transB2 transC2 transD2))


; unfold 3
(synth-fun transA3 () Bool)
(synth-fun transB3 () Bool)
(synth-fun transC3 () Bool)
(synth-fun transD3 () Bool)
(constraint (T transA2 transB2 transC2 transD2 transA3 transB3 transC3 transD3))


; specification: may have transmitted to D by time 3
(constraint transD3)


(check-synth)
