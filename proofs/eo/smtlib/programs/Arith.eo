(include "../theories/Ints.eo")
(include "../theories/Arith.eo")
(include "../programs/Utils.eo")

; program: $eval_int_log_2_rec
; args:
; - x  Int: The term to compute the log (base 2) of, assumed to be a positive numeral value.
; return: The log base 2 of x.
; note: Helper method for $eval_int_log_2 below.
(program $eval_int_log_2_rec ((x Int))
  (Int) Int
  (
  (($eval_int_log_2_rec 1) 0)
  (($eval_int_log_2_rec x) (eo::add 1 ($eval_int_log_2_rec (eo::zdiv x 2))))
  )
)

; define: $eval_int_log_2
; args:
; - x Int: The term to compute the log (base 2) of.
; return: >
;   the log base 2 of x. If x is not strictly positive, we return
;   the term (int.log2 x).
(define $eval_int_log_2 ((x Int))
  (eo::ite (eo::is_neg (eo::neg x)) ($eval_int_log_2_rec x) (int.log2 x)))

; program: $eval_int_pow_2_rec
; args:
; - x  Int: The term to compute 2 to the power of, assumed to be a positive numeral value.
; return: 2 to the power of x.
; note: Helper method for $eval_int_pow_2 below.
(program $eval_int_pow_2_rec ((x Int))
  (Int) Int
  (
  (($eval_int_pow_2_rec 0) 1)
  (($eval_int_pow_2_rec x) (eo::mul 2 ($eval_int_pow_2_rec (eo::add x -1))))
  )
)

; define: $eval_int_pow_2
; args:
; - x Int: The term to compute take as the exponent of two.
; return: >
;   two raised to the power of x. If x is not a numeral value, we return
;   the term (int.pow2 x).
(define $eval_int_pow_2 ((x Int))
  (eo::ite (eo::is_z x)
    (eo::ite (eo::is_neg x) 0 ($eval_int_pow_2_rec x))
    (int.pow2 x)))

; program: $eval_int_is_pow_2_rec
; args:
; - x  Int: The term to compute whether it is a power of two, assumed to be a positive numeral value.
; return: true iff x is a power of two.
; note: Helper method for $eval_is_pow_2 below.
(program $eval_int_is_pow_2_rec ((x Int))
  (Int) Bool
  (
  (($eval_int_is_pow_2_rec 1) true)
  (($eval_int_is_pow_2_rec x) (eo::ite (eo::is_eq (eo::zmod x 2) 0)
                                      ($eval_int_is_pow_2_rec (eo::zdiv x 2))
                                      false))
  )
)

; define: $eval_is_pow_2
; args:
; - x Int: The term to compute whether it is a power of two.
; return: >
;   true iff x is a power of two. If x is not a numeral value, we return
;   the term (int.ispow2 x).
(define $eval_int_is_pow_2 ((x Int))
  (eo::ite (eo::is_z x) 
    (eo::ite (eo::is_neg x) false ($eval_int_is_pow_2_rec x))
    (int.ispow2 x)))

; define: $arith_unfold_pow_rec
; args:
; - n Int: The number of times to multiply, expected to be a non-negative numeral.
; - a T: The term to muliply.
; return: The result of multiplying a, n times.
(program $arith_unfold_pow_rec ((T Type) (n Int) (a T))
  (Int T) T
  (
    (($arith_unfold_pow_rec 0 a)  1)
    (($arith_unfold_pow_rec n a)  (eo::cons * a ($arith_unfold_pow_rec (eo::add n -1) a)))
  )
)

; define: $arith_unfold_pow
; args:
; - n Int: The number of times to multiply.
; - a T: The term to muliply.
; return: The result of multiplying a, n times. If n is not a positive numeral, this returns (^ a n).
(define $arith_unfold_pow ((T Type :implicit) (n Int) (a T))
  (eo::ite (eo::and (eo::is_z n) (eo::not (eo::is_neg n)))
    ($arith_unfold_pow_rec n a)
    (^ a n)))
