(include "../theories/Builtin.eo")

(declare-const Int Type)
(declare-const Real Type)

(declare-consts <numeral> Int)
(declare-consts <rational> Real)

; define: $arith_mk_zero
; args:
; - u Type : The type of the zero, which should be Int or Real.
; return: the zero for the given type.
(define $arith_mk_zero ((T Type))
  (eo::ite (eo::is_eq T Int) 0 (eo::requires T Real 0/1)))

; define: $arith_mk_one
; args:
; - u Type : The type of the zero, which should be Int or Real.
; return: the zero for the given type.
(define $arith_mk_one ((T Type))
  (eo::ite (eo::is_eq T Int) 1 (eo::requires T Real 1/1)))

; program: $arith_typeunion
; args:
; - T Type: An arithmetic type.
; - U Type: An arithmetic type.
; return: >
;   The "type union" of T and U. This method is used for the type rules
;   for operators that allow mixed arithmetic.
(program $arith_typeunion ()
    :signature (Type Type) Type
    (
      (($arith_typeunion Int Int) Int)
      (($arith_typeunion Real Real) Real)
      (($arith_typeunion Real Int) Real)
      (($arith_typeunion Int Real) Real)
    )
)

; program: $is_arith_type
; args:
; - T Type: A type.
; return: true if T is Int or Real
(program $is_arith_type ()
    :signature (Type) Bool
    (
      (($is_arith_type Int) true)
      (($is_arith_type Real) true)
    )
)

; Core operators of arithmetic, which are used in mixed Int/Real arithmetic.
; Using integer nil terminators ensures typing is accurate.
; disclaimer: >
;   This function is declared to be :left-assoc in SMT-LIB. We declare
;   it with right-assoc-nil to model cvc5's treatment of variadic functions.
(declare-parameterized-const + ((T Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true T)) :right-assoc-nil ($arith_mk_zero T))
; disclaimer: This function is overloaded in SMT-LIB and does not permit mixed arithmetic.
(declare-parameterized-const - ((T Type :implicit) (U Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true T)) :left-assoc)
; disclaimer: >
;   This function is declared to be :left-assoc in SMT-LIB. We declare
;   it with right-assoc-nil to model cvc5's treatment of variadic functions.
(declare-parameterized-const * ((T Type :implicit) (U Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true T)) :right-assoc-nil ($arith_mk_one T))

(declare-parameterized-const < ((T Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true Bool))
      :chainable and)
(declare-parameterized-const <= ((T Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true Bool))
      :chainable and)
(declare-parameterized-const > ((T Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true Bool))
      :chainable and)
(declare-parameterized-const >= ((T Type :implicit))
  (-> T T (eo::requires ($is_arith_type T) true Bool))
      :chainable and)

; Conversion functions.
; disclaimer: The type of this function in SMT-LIB only accepts an Int as argument.
(declare-parameterized-const to_real ((T Type :implicit))
  (-> T (eo::requires ($is_arith_type T) true Real)))
; disclaimer: The type of this function in SMT-LIB only accepts a Real as argument.
(declare-parameterized-const to_int ((T Type :implicit))
  (-> T (eo::requires ($is_arith_type T) true Int)))
; disclaimer: The type of this function in SMT-LIB only accepts a Real as argument.
(declare-parameterized-const is_int ((T Type :implicit))
  (-> T (eo::requires ($is_arith_type T) true Bool)))
; disclaimer: The type of this function in SMT-LIB only accepts an Int as argument.
(declare-parameterized-const abs ((T Type :implicit))
  (-> T (eo::requires ($is_arith_type T) true T)))

; Unary negation, which is overloaded with binary subtraction. Note we declare
; unary negation after binary substraction, meaning that in contexts where it is
; overloaded, unary negation takes precedence.
(declare-parameterized-const - ((T Type :implicit))
  (-> T (eo::requires ($is_arith_type T) true T)))
