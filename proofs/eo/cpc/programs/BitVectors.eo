(include "../theories/BitVectors.eo")

; define: $bv_sign_bit
; args:
; - b (BitVec m): The bitvector term.
; return: The sign bit of b.
(define $bv_sign_bit ((m Int :implicit) (b (BitVec m)))
  (eo::define ((T (eo::typeof b)))
  (eo::define ((w ($bv_bitwidth T)))
  (eo::define ((wm1 (eo::add w -1)))
    (eo::extract b wm1 wm1)))))

; define: $bv_ones
; args:
; - m Int: The bitwidth.
; return: The bitvector of width m containing all ones.
(define $bv_ones ((m Int))
  (eo::to_bin m (eo::add ($arith_eval_int_pow_2 m) -1)))

; define: $bv_to_signed_int
; args:
; - b (BitVec m): The bitvector term.
; return: The result of converting b to a signed integer.
(define $bv_to_signed_int ((m Int :implicit) (b (BitVec m)))
  (eo::define ((T (eo::typeof b)))
  (eo::define ((w ($bv_bitwidth T)))
  (eo::define ((wm1 (eo::add w -1)))
  (eo::define ((z (eo::to_z (eo::extract b 0 (eo::add w -2)))))
    (eo::ite (eo::is_eq ($bv_sign_bit b) #b1)
      (eo::add (eo::neg ($arith_eval_int_pow_2 wm1)) z)
      z))))))

; define: $bv_unfold_repeat_rec
; args:
; - n Int: The number of times to repeat, expected to be a non-negative numeral.
; - b (BitVec m): The bitvector term.
; return: The result of concatenating b n times.
(program $bv_unfold_repeat_rec ((m Int) (n Int) (b (BitVec m)))
  (Int (BitVec m)) (BitVec (eo::mul n m))
  (
    (($bv_unfold_repeat_rec 0 b)  (eo::to_bin 0 0))
    (($bv_unfold_repeat_rec n b)  (eo::cons concat b ($bv_unfold_repeat_rec (eo::add n -1) b)))
  )
)

; define: $bv_unfold_repeat
; args:
; - n Int: The number of times to repeat, expected to be a non-negative numeral.
; - b (BitVec m): The bitvector term.
; return: >
;   The result of concatenating b n times. If n is not a numeral or is negative,
;   this returns the term (repeat n b).
(define $bv_unfold_repeat ((m Int :implicit) (n Int) (b (BitVec m)))
  (eo::ite (eo::and (eo::is_z n) (eo::not (eo::is_neg n)))
    ($bv_unfold_repeat_rec n b)
    (repeat n b)))

; program: $bv_get_first_const_child
; args:
; - a (BitVec n): The term to find a constant child in.
; return: >
;   The first direct child of a that it is a bitvector constant if one exists,
;   or the term @bv_empty otherwise.
(program $bv_get_first_const_child ((n Int) (m Int) (k Int) (f (-> (BitVec n) (BitVec m) (BitVec k))) (a (BitVec n)) (b (BitVec m) :list))
  ((BitVec k)) (BitVec n)
  (
    (($bv_get_first_const_child (f a b))  (eo::ite (eo::is_bin a) a ($bv_get_first_const_child b)))
    (($bv_get_first_const_child a)        @bv_empty)    ; indicates no child
  )
)

; define: $bv_bit_set
; args:
; - a (BitVec n): The bitvector to inspect, in little endian form.
; - i Int: The index of the bit.
; return: true if the i^th bit of a is set.
(define $bv_bit_set ((n Int :implicit) (a (BitVec n)) (i Int))
  (eo::is_eq (eo::extract a i i) #b1))

; program: $bv_const_to_bitlist_rec
; args:
; - c (BitVec n): The bitvector constant to process.
; - i Int: The index we are currently processing.
; return: the bitlist for a starting with index i.
(program $bv_const_to_bitlist_rec ((n Int) (c (BitVec n)) (i Int))
  ((BitVec n) Int) (BitVec n)
  (
    (($bv_const_to_bitlist_rec c -1)  @bv_empty)
    (($bv_const_to_bitlist_rec c i)   (eo::cons @from_bools ($bv_bit_set c i) ($bv_const_to_bitlist_rec c (eo::add i -1))))
  )
)

; define: $bv_const_to_bitlist
; args:
; - c (BitVec n): The bitvector constant to process.
; return: >
;   The bitlist for c, which is a term of the form
;   (@from_bools a1 ...(@from_bools an @bv_empty)) where a1...an are
;   the bits of c, considered in little endian form.
(define $bv_const_to_bitlist ((n Int :implicit) (c (BitVec n)))
  ($bv_const_to_bitlist_rec c (eo::add (eo::len c) -1)))
  
; define: $nary_app
; args:
; - f (-> T U V): The function to apply, which is assumed to be
; right-associative with a nil terminator.
; - a T: The first argument.
; - b U: The second argument.
; return: the term (f a b).
; note: >
;   This is a helpful method for constructing n-ary terms with exactly two
;   children.
(define $nary_app ((T Type :implicit) (U Type :implicit) (V Type :implicit) (f (-> T U V)) (a T) (b U))
  (f a (f b (eo::nil f a b))))


;;;;; evaluation utils

; define: $bv_smulo_elim
; args:
; - xa (BitVec n): An xor term involving the first argument to bvsmulo
; - xb (BitVec n): An xor term involving the second argument to bvsmulo
; - ppc (BitVec 1): An intermediate bitvector term accumulated to help construct the result.
; - res (BitVec 1): The current accumulated result.
; - i Int: The current bit we are processing.
; - nm2 Int: The bitwidth of a and b minus 2.
; return: >
;   A portion of the result of eliminating (bvsmulo a b).
(program $bv_smulo_elim_rec ((n Int) (xa (BitVec n)) (xb (BitVec n))
                             (ppc (BitVec 1)) (res (BitVec 1)) (i Int) (nm2 Int))
  ((BitVec n) (BitVec n) (BitVec 1) (BitVec 1) Int Int) (BitVec 1)
  (
  (($bv_smulo_elim_rec xa xb ppc res nm2 nm2)   res)
  (($bv_smulo_elim_rec xa xb ppc res i nm2)
      (eo::define ((ia (eo::add nm2 (eo::neg i))))
      (eo::define ((ip1 (eo::add i 1)))
      (eo::define ((ppcn (bvor ppc (extract ia ia xa))))
        ($bv_smulo_elim_rec xa xb ppcn (bvor res (bvand (extract ip1 ip1 xb) ppcn)) ip1 nm2)))))
  )
)

; define: $bv_smulo_elim
; args:
; - a (BitVec n): The first argument to bvsmulo
; - b (BitVec n): The second argument to bvsmulo
; return: >
;   The result of eliminating (bvsmulo a b).
(define $bv_smulo_elim ((n Int :implicit) (a (BitVec n)) (b (BitVec n)))
  (eo::define ((w ($bv_bitwidth (eo::typeof a))))
  (eo::define ((wm1 (eo::add w -1)))
  (eo::define ((one (eo::to_bin 1 1)))
  (eo::ite (eo::is_eq w 1)
    (= (bvand a b) one)
    (eo::define ((mul (bvmul (sign_extend 1 a) (sign_extend 1 b))))
    (eo::ite (eo::is_eq w 2)
      (= (bvxor (extract w w mul) (extract wm1 wm1 mul)) one)
      (eo::define ((xa (bvxor a (sign_extend wm1 (extract wm1 wm1 a)))))
      (eo::define ((xb (bvxor b (sign_extend wm1 (extract wm1 wm1 b)))))
      (eo::define ((wm2 (eo::add w -2)))
      (eo::define ((ppc (extract wm2 wm2 xa)))
      (eo::define ((res ($bv_smulo_elim_rec xa xb ppc (bvand (extract 1 1 b) ppc) 1 wm2)))
        (= (bvor res (bvxor (extract w w mul) (extract wm1 wm1 mul))) one))))))))))))
)

; define: $bv_umulo_elim_rec
; args:
; - xa (BitVec n): An xor term involving the first argument to bvumulo
; - xb (BitVec n): An xor term involving the second argument to bvumulo
; - ppc (BitVec 1): An intermediate bitvector term accumulated to help construct the result.
; - res (BitVec 1): The current accumulated result.
; - i Int: The current bit we are processing.
; - nm2 Int: The bitwidth of a and b minus 2.
; return: >
;   A portion of the result of eliminating (bvsmulo a b).
(program $bv_umulo_elim_rec ((n Int) (a (BitVec n)) (b (BitVec n))
                             (uppc (BitVec 1)) (res (BitVec 1)) (i Int))
  ((BitVec n) (BitVec n) (BitVec 1) (BitVec 1) Int Int) (BitVec 1)
  (
  (($bv_umulo_elim_rec a b uppc res n n)   res)
  (($bv_umulo_elim_rec a b uppc res i n)
      (eo::define ((ia (eo::add n -1 (eo::neg i))))
      (eo::define ((ip1 (eo::add i 1)))
      (eo::define ((uppcn (bvor uppc (extract ia ia a))))
        (eo::cons bvor (bvand (extract i i b) uppc) ($bv_umulo_elim_rec a b uppcn res ip1 n))))))
  )
)

; define: $bv_umulo_elim
; args:
; - a (BitVec n): The first argument to bvumulo
; - b (BitVec n): The second argument to bvumulo
; return: >
;   The result of eliminating (bvumulo a b).
(define $bv_umulo_elim ((n Int :implicit) (a (BitVec n)) (b (BitVec n)))
  (eo::define ((w ($bv_bitwidth (eo::typeof a))))
  (eo::ite (eo::is_eq w 1)
    false
    (eo::define ((wm1 (eo::add w -1)))
    (eo::define ((zero (eo::to_bin 1 0)))
    (eo::define ((uppc (extract wm1 wm1 a)))
    (eo::define ((mul (bvmul (concat zero a) (concat zero b))))
    (eo::define ((res ($bv_umulo_elim_rec a b uppc (bvor (extract w w mul)) 1 w)))
      (= res (eo::to_bin 1 1))))))))))
