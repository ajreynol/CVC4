(include "../programs/BitVectors.eo")

;;; utils

(program $bv_ripple_carry_adder_2 ((n Int) (b1 Bool) (b2 Bool) (a1 (BitVec n) :list) (a2 (BitVec n) :list) (carry Bool) (res (BitVec n)))
  ((BitVec n) (BitVec n) Bool (BitVec n)) (@Pair Bool (BitVec n))
  (
  (($bv_ripple_carry_adder_2 (@from_bools b1 a1) (@from_bools b2 a2) carry res) ($bv_ripple_carry_adder_2 a1 a2 
                                                                                  (or (and b1 b2) (and (xor b1 b2) carry))
                                                                                  (eo::cons @from_bools (xor (xor b1 b2) carry) res)))
  (($bv_ripple_carry_adder_2 @bv_empty @bv_empty carry res)                     (@pair carry ($nary_reverse res)))
  )
)

(define $bv_ripple_carry_adder ((n Int :implicit) (a1 (BitVec n)) (a2 (BitVec n)) (carry Bool))
  (eo::match ((m Int) (carryr Bool) (res (BitVec m)))
    ($bv_ripple_carry_adder_2 a1 a2 carry @bv_empty)
    (((@pair carryr res) res))))

;;; not

(program $bv_mk_bitblast_step_not ((f (-> Bool Bool Bool)) (b1 Bool) (n Int) (m Int) (a1 (BitVec m) :list))
  ((BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_not @bv_empty)           @bv_empty)
  (($bv_mk_bitblast_step_not (@from_bools b1 a1)) (eo::cons @from_bools (not b1) ($bv_mk_bitblast_step_not a1)))
  )
)

;;; left shift


;;; equality

; program: $bv_mk_bitblast_step_eq
; args:
; - x T: The left hand side of the equality.
; - y T: The right hand side of the equality.
; return: the bitblasted term for (= x y).
(program $bv_mk_bitblast_step_eq ((T Type) (W Type) (b1 Bool) (b2 Bool) (a1 W :list) (a2 W :list))
  (T T) Bool
  (
  (($bv_mk_bitblast_step_eq @bv_empty @bv_empty)                      true)
  (($bv_mk_bitblast_step_eq (@from_bools b1 a1) (@from_bools b2 a2))  (eo::cons and (= b1 b2) ($bv_mk_bitblast_step_eq a1 a2)))
  )
)


;;; inequality

(program $bv_bitblast_ult_rec ((n Int) (b1 Bool) (b2 Bool) (a1 (BitVec n) :list) (a2 (BitVec n) :list) (res Bool))
  ((BitVec n) (BitVec n) Bool) Bool
  (
  (($bv_bitblast_ult_rec @bv_empty @bv_empty res)                      res)
  (($bv_bitblast_ult_rec (@from_bools b1 a1) (@from_bools b2 a2) res)  ($bv_bitblast_ult_rec a1 a2 (or (and (= b1 b2) res) (and (not b1) b2))))
  )
)

(program $bv_bitblast_ult ((n Int) (b1 Bool) (b2 Bool) (a1 (BitVec n) :list) (a2 (BitVec n) :list) (orEqual Bool))
  ((BitVec n) (BitVec n) Bool) Bool
  (
  (($bv_bitblast_ult (@from_bools b1 a1) (@from_bools b2 a2) orEqual)  (eo::define ((res (and (not b1) b2)))
                                                                       (eo::define ((res2 (eo::ite orEqual (or res (= b1 b2)) res)))
                                                                          ($bv_bitblast_ult_rec a1 a2 res))))
  )
)

(program $bv_bitblast_slt_impl ((n Int) (b1 Bool) (b2 Bool) (a1 (BitVec n) :list) (a2 (BitVec n) :list) (orEqual Bool))
  ((BitVec n) (BitVec n) Bool) Bool
  (
  (($bv_bitblast_slt_impl (@from_bools b1) (@from_bools b2) orEqual)        (eo::ite orEqual (or (= b1 b2) (and b1 (not b2))) (and b1 (not b2))))
  (($bv_bitblast_slt_impl (@from_bools b1 a1) (@from_bools b2 a2) orEqual)  (eo::define ((ures ($bv_bitblast_ult ($nary_reverse a1) ($nary_reverse a2) orEqual)))
                                                                              (or (and (= b1 b2) ures) (and b1 (not b2)))))
  )
)

(define $bv_bitblast_slt ((n Int :implicit) (a1 (BitVec n)) (a2 (BitVec n)) (orEqual Bool))
  ; reverse to make sign bit extractable
  ($bv_bitblast_slt_impl ($nary_reverse a1) ($nary_reverse a2) orEqual))

;;; extract

; define: $bv_mk_bitblast_step_extract
; args:
; - u Int: The upper index of the extract.
; - l Int: The lower index of the extract.
; - a (BitVec n): The argument of the extract.
; return: the bitblasted term for (extract u l a).
(define $bv_mk_bitblast_step_extract ((n Int :implicit) (u Int) (l Int) (a (BitVec n)))
  ($nary_subsequence @from_bools @bv_empty l u a))

;;; concat

; program: $bv_mk_bitblast_step_concat_rec
; args:
; - a (BitVec n): The (reverse) of the bitvector concatenation term to process.
; return: >
;   The bitblasted term for concatenation term a, reversed. We require reversing
;   the concatenation term to this method to match the bitblasted form that is
;   generated.
(program $bv_mk_bitblast_step_concat_rec ((n Int) (a1 (BitVec n)) (m Int) (a2 (BitVec m) :list))
  ((BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_concat_rec @bv_empty)      @bv_empty)
  (($bv_mk_bitblast_step_concat_rec (concat a1 a2)) (eo::list_concat @from_bools a1 ($bv_mk_bitblast_step_concat_rec a2)))
  )
)

; define: $bv_mk_bitblast_step_concat
; args:
; - a (BitVec n): The bitvector concatenation term to process.
; return: the bitblasted term for concatenation term a.
(define $bv_mk_bitblast_step_concat ((n Int :implicit) (a (BitVec n)))
  ($bv_mk_bitblast_step_concat_rec ($nary_reverse a)))

;;; bitwise

(program $bv_mk_bitwise_nary_app ((f (-> Bool Bool Bool)) (b1 Bool) (b2 Bool) (n Int) (m Int) (a1 (BitVec m) :list) (a2 (BitVec m) :list))
  ((-> Bool Bool Bool) (BitVec n) (BitVec n)) (BitVec n)
  (
  (($bv_mk_bitwise_nary_app f @bv_empty @bv_empty)                     @bv_empty)
  (($bv_mk_bitwise_nary_app f (@from_bools b1 a1) (@from_bools b2 a2)) (eo::cons @from_bools ($nary_app f b1 b2) ($bv_mk_bitwise_nary_app f a1 a2)))
  )
)

(program $bv_mk_bitwise_app ((f (-> Bool Bool Bool)) (b1 Bool) (b2 Bool) (n Int) (m Int) (a1 (BitVec m) :list) (a2 (BitVec m) :list))
  ((-> Bool Bool Bool) (BitVec n) (BitVec n)) (BitVec n)
  (
  (($bv_mk_bitwise_app f @bv_empty @bv_empty)                     @bv_empty)
  (($bv_mk_bitwise_app f (@from_bools b1 a1) (@from_bools b2 a2)) (eo::cons @from_bools (f b1 b2) ($bv_mk_bitwise_app f a1 a2)))
  )
)

; program: $bv_mk_bitblast_step_bitwise
; args:
; - bf (-> (BitVec n) (BitVec n) (BitVec n)): The bitvector function.
; - f (-> (BitVec n) (BitVec n) (BitVec n)): The Boolean function.
; - a (BitVec n): The term we are bitblasting, expected to be an application of bf to @from_bools arguments.
; - ac (BitVec n): The accumulated return value.
; return: the bitblasted version of a.
(program $bv_mk_bitblast_step_bitwise ((n Int) (bf (-> (BitVec n) (BitVec n) (BitVec n))) (f (-> Bool Bool Bool)) (a1 (BitVec n)) (a2 (BitVec n) :list) (ac (BitVec n)))
  ((-> (BitVec n) (BitVec n) (BitVec n)) (-> Bool Bool Bool) (BitVec n) (BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_bitwise bf f (bf a1 a2) ac)    ($bv_mk_bitblast_step_bitwise bf f a2 ($bv_mk_bitwise_app f ac a1)))
  (($bv_mk_bitblast_step_bitwise bf f a2 ac)            ac)
  )
)
(program $bv_mk_bitblast_step_bitwise_nary ((n Int) (bf (-> (BitVec n) (BitVec n) (BitVec n))) (f (-> Bool Bool Bool)) (a1 (BitVec n)) (a2 (BitVec n) :list) (ac (BitVec n)))
  ((-> (BitVec n) (BitVec n) (BitVec n)) (-> Bool Bool Bool) (BitVec n) (BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_bitwise_nary bf f (bf a1 a2) ac)    ($bv_mk_bitblast_step_bitwise_nary bf f a2 ($bv_mk_bitwise_nary_app f ac a1)))
  (($bv_mk_bitblast_step_bitwise_nary bf f a2 ac)            ac)
  )
)

;;; addition

(program $bv_mk_bitblast_step_add ((n Int) (a1 (BitVec n)) (a2 (BitVec n) :list) (ac (BitVec n)))
  ((BitVec n) (BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_add (bvadd a1 a2) ac) ($bv_mk_bitblast_step_add a2 ($bv_ripple_carry_adder ac a1 false)))
  (($bv_mk_bitblast_step_add a2 ac)            ac)
  )
)

;;; constants

; program: $bv_const_to_bitlist_rec
; args:
; - c (BitVec n): The bitvector constant to process.
; - i Int: The index we are currently processing.
; return: the bitlist for a starting with index i.
(program $bv_const_to_bitlist_rec ((n Int) (c (BitVec n)) (i Int))
  ((BitVec n) Int) (BitVec n)
  (
    (($bv_const_to_bitlist_rec c -1)  @bv_empty)
    (($bv_const_to_bitlist_rec c i)   (eo::cons @from_bools ($bv_bit_set c i) ($bv_const_to_bitlist_rec c (eo::add i -1))))
  )
)

; define: $bv_const_to_bitlist
; args:
; - c (BitVec n): The bitvector constant to process.
; return: >
;   The bitlist for c, which is a term of the form
;   (@from_bools a1 ...(@from_bools an @bv_empty)) where a1...an are
;   the bits of c, considered in little endian form.
(define $bv_const_to_bitlist ((n Int :implicit) (c (BitVec n)))
  ($bv_const_to_bitlist_rec c (eo::add (eo::len c) -1)))

; define: $bv_mk_bitblast_step_const
; args:
; - a (BitVec n): The bitvector constant to bitblast.
; return: the bitblasted term for a, which is its reverse bitlist.
(define $bv_mk_bitblast_step_const ((n Int :implicit) (a (BitVec n)))
  ($nary_reverse ($bv_const_to_bitlist a)))

;;; variables

; program: $bv_mk_bitblast_step_var_rec
; args:
; - a (BitVec n): The bitvector variable to bitblast.
; - i Int: The index of the bit we are currently processing.
; return: the bitblasted term for variable a.
(program $bv_mk_bitblast_step_var_rec ((n Int) (a (BitVec n)) (i Int))
  ((BitVec n) Int) (BitVec n)
  (
    (($bv_mk_bitblast_step_var_rec a -1)  @bv_empty)
    (($bv_mk_bitblast_step_var_rec a i)   (eo::cons @from_bools (@bit i a) ($bv_mk_bitblast_step_var_rec a (eo::add i -1))))
  )
)

; define: $bv_mk_bitblast_step_var
; args:
; - a (BitVec n): The bitvector variable to bitblast.
; return: the bitblasted term for variable a.
(define $bv_mk_bitblast_step_var ((n Int :implicit) (a (BitVec n)))
  ($nary_reverse ($bv_mk_bitblast_step_var_rec a (eo::add ($bv_bitwidth (eo::typeof a)) -1))))

;;; $bv_mk_bitblast_step

; define: $bv_mk_bitblast_step
; args:
; - a T: The bitvector term or predicate to bitblast.
; return: the bitblasted term for a.
(define $bv_mk_bitblast_step ((T Type :implicit) (a T))
  (eo::match ((n Int) (a1 (BitVec n)) (a2 (BitVec n) :list) (u Int) (l Int) (m Int) (a3 (BitVec m) :list))
  a
  (
  ((bvnot a1)       ($bv_mk_bitblast_step_not a1))
  ((= a1 a2)        ($singleton_elim ($bv_mk_bitblast_step_eq a1 a2)))
  ((bvult a1 a2)    ($bv_bitblast_ult a1 a2 false))
  ((bvule a1 a2)    ($bv_bitblast_ult a1 a2 true))
  ((bvslt a1 a2)    ($bv_bitblast_slt a1 a2 false))
  ((bvsle a1 a2)    ($bv_bitblast_slt a1 a2 true))
  ((extract u l a1) ($bv_mk_bitblast_step_extract u l a1))
  ((concat a1 a3)   ($bv_mk_bitblast_step_concat a))
  ((bvor a1 a2)     ($bv_mk_bitblast_step_bitwise_nary bvor or a2 a1))
  ((bvand a1 a2)    ($bv_mk_bitblast_step_bitwise_nary bvand and a2 a1))
  ((bvxor a1 a2)    ($bv_mk_bitblast_step_bitwise bvxor xor a2 a1))
  ((bvxnor a1 a2)   ($bv_mk_bitwise_app = a1 a2))
  ((bvadd a1 a2)    ($bv_mk_bitblast_step_add a2 a1))
  ((bvsub a1 a2)    ($bv_ripple_carry_adder a1 ($bv_mk_bitblast_step_not a2) true))
  (a1               (eo::ite (eo::is_bin a)
                      ($bv_mk_bitblast_step_const a)
                      ($bv_mk_bitblast_step_var a)))    ; otherwise assume a variable
  ))
)
