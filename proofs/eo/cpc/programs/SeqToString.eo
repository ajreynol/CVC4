(include "../theories/Datatypes.eo")

(include "DistinctValues.eo")

(program $seq_to_string_rec ((T Type) (t T) (ss (Seq T) :list) (s String) (units @List) (chars @List) (n Int))
  ((Seq T) String @List @List Int) (Tuple String @List @List)
  (
    (($seq_to_string_rec (seq.unit t) s units chars n)              (eo::define ((u (seq.unit t)))
                                                                    ($seq_to_string_rec (eo::cons seq.++ u (@seq.empty (eo::typeof u))) s units chars n)))
    (($seq_to_string_rec (seq.++ (seq.unit t) ss) s units chars n)  (eo::define ((u (seq.unit t)))
                                                                    (eo::define ((id (eo::list_find @list units u)))
                                                                    (eo::ite (eo::is_neg id)
                                                                      ; already allocated
                                                                      (eo::define ((nchar (eo::to_str id)))
                                                                      ($seq_to_string_rec
                                                                        ss
                                                                        (eo::concat nchar s)
                                                                        units
                                                                        chars
                                                                        n))
                                                                      ; else, allocate new
                                                                      ; requires proving that the current character is distinct from all others
                                                                      (eo::requires ($are_distinct_terms_list_rec u units (eo::typeof u)) true
                                                                        (eo::define ((nchar (eo::to_str n)))
                                                                        ($seq_to_string_rec
                                                                          ss
                                                                          (eo::concat nchar s)
                                                                          (eo::cons @list u units)
                                                                          (eo::cons @list nchar chars)
                                                                          (eo::add n 1))))))))
    (($seq_to_string_rec (@seq.empty T) s units chars n)            (tuple s units chars))
  )
)

(define $seq_to_string ((T Type :implicit) (s (Seq T)))
  (eo::ite (eo::is_str s)
    s   ; may already be a string
    (eo::match ((ss String) (nunits @List) (nchars @List))
      ($seq_to_string_rec s "" @list.nil @list.nil 0)
      (((tuple ss nunits nchars) ss)))))


(program $seq_to_string_op_rec ((U Type) (T Type) (f (-> T U)) (a T) (units @List) (chars @List))
  (T @List @List) (Tuple T @List @List)
  (
  (($seq_to_string_op_rec (f a) units chars)  (eo::match ((U Type))
                                                  (eo::typeof a)
                                                  (
                                                    ((Seq U) (eo::match ((s String) (nunits @List) (nchars @List))
                                                              ($seq_to_string_rec a "" units chars (eo::list_len @list units))
                                                              (((tuple s nunits nchars)  (_ ($seq_to_string_op_rec f nunits nchars) s)))))
                                                    (U       (_ ($seq_to_string_op_rec f units chars) a))
                                                  )))
  (($seq_to_string_op_rec a units chars)      a)
  )
)

;(include "Strings.eo")
;(include "Quantifiers.eo")
;(define $string_to_seq ((s String) (units @List) (chars @List))
;  ($substitute_list ($str_flatten_word s) chars units))
