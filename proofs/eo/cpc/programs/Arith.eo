(include "../theories/Ints.eo")
(include "../theories/Arith.eo")
(include "../programs/Utils.eo")

; define: $sgn
; args:
; - x T: The term to inspect. Assumed to be an arithmetic value.
; return: The sign of x: -1 if x < 0, 1 if x > 0, and 0 otherwise.
(define $sgn ((T Type :implicit) (x T))
  (eo::ite (eo::is_neg x) -1 (eo::ite (eo::is_neg (eo::neg x)) 1 0)))

; define: $arith_mk_binary_minus
; args:
; - x T: the first term
; - y U: the second term
; return: The subtraction of x and y.
; note: >
;   This macro is necessary to use in contexts where the types of the
;   arguments cannot be statically computed.
(define $arith_mk_binary_minus ((T Type :implicit) (U Type :implicit) (x T) (y U)) (- x y))

; program: $arith_eval_int_log_2_rec
; args:
; - x  Int: The term to compute the log (base 2) of, assumed to be a positive numeral value.
; return: The log base 2 of x.
; note: Helper method for $arith_eval_int_log_2 below.
(program $arith_eval_int_log_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_log_2_rec 1) 0)
  (($arith_eval_int_log_2_rec x) (eo::add 1 ($arith_eval_int_log_2_rec (eo::zdiv x 2))))
  )
)

; define: $arith_eval_int_log_2
; args:
; - x Int: The term to compute the log (base 2) of.
; return: >
;   the log base 2 of x. If x is not strictly positive, we return 0.
(define $arith_eval_int_log_2 ((x Int))
  (eo::ite (eo::is_neg (eo::neg x)) ($arith_eval_int_log_2_rec x) 0))

; program: $arith_eval_int_pow_2_rec
; args:
; - x  Int: The term to compute 2 to the power of, assumed to be a positive numeral value.
; return: 2 to the power of x.
; note: Helper method for $arith_eval_int_pow_2 below.
(program $arith_eval_int_pow_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_pow_2_rec 0) 1)
  (($arith_eval_int_pow_2_rec x) (eo::mul 2 ($arith_eval_int_pow_2_rec (eo::add x -1))))
  )
)

; define: $arith_eval_int_pow_2
; args:
; - x Int: The term to compute take as the exponent of two.
; return: >
;   two raised to the power of x. If x is not a numeral value, we return
;   the term (int.pow2 x).
(define $arith_eval_int_pow_2 ((x Int))
  (eo::ite (eo::is_z x)
    (eo::ite (eo::is_neg x) 0 ($arith_eval_int_pow_2_rec x))
    (int.pow2 x)))

; define: $arith_eval_is_pow_2
; args:
; - x Int: The term to compute whether it is a power of two.
; return: >
;   true iff x is a power of two. If x is not a numeral value, we return
;   the term (int.ispow2 x).
(define $arith_eval_int_is_pow_2 ((x Int))
  (eo::ite (eo::is_z x) 
    (eo::ite (eo::is_neg x)
      false
      (eo::eq x ($arith_eval_int_pow_2 ($arith_eval_int_log_2 x))))
    (int.ispow2 x)))
